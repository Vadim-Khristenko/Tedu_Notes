# Конспект от 04.10.2025 | Параллель B
## Тема: Древо отрезков и его применение

> Автор: Вадим Христенкко  
> Дружеский конспект — просто и понятно о сложных вещах.  
> Разбор задачек будет потом отдельно в другом файле заисключением последних двух задач.  
> Они будут разобраны здесь же.

> Примечание-дисклеймер: голова адски болит (вероятно перевозбуждение синопсов и недосып), так что возможны ошибки формулировок и опечатки. После появления записи лекции планирую перепроверить и переписать спорные места. Если что-то выглядит странно — пиши, поправим.

---

## Оглавление

1. [Разбор задачки L (возможны неточности)](#разбор-задачки-l-возможны-неточности)
    1. [Формулировка](#1-формулировка-перефраз)
    2. [Главная редукция](#2-главная-редукция)
    3. [Стандартный DFS и рёбра](#3-стандартный-dfs-и-классификация-рёбер)
    4. [Фактор паритета](#4-фактор-паритета)
    5. [Фундаментальные циклы — почему хватает](#5-почему-достаточно-фундаментальных-нечётных-циклов)
    6. [Покрытие путей](#6-задача-сводится-к-подсчёту-покрытия-путей)
    7. [Дифференциальная маркировка](#7-дифференциальная-маркировка-путей-без-обхода-каждого-пути-целиком)
    8. [Компоненты](#8-обработка-всех-компонент)
    9. [Фильтрация back-рёбер](#9-паритет-и-фильтрация-back-рёбер)
    10. [Критерий ответа](#10-обоснование-корректности-критерия-ответа)
    11. [Граничные случаи](#11-разбор-типичных-граничных-случаев)
    12. [Иллюстрация](#12-иллюстрация-mermaid)
    13. [Память и масштабируемость](#13-память-и-масштабируемость)
    14. [Сложность](#14-временная-сложность)
    15. [Корректность формулы пути](#15-корректность-формулы-для-включительного-пути)
    16. [Ошибки](#16-частые-ошибки)
    17. [Алгоритм словом](#17-итоговая-словесная-схема-алгоритм-без-кода)
    18. [Резюме](#18-резюме)
2. [Дерево отрезков (Segment Tree) — расширенный блок](#дерево-отрезков-segment-tree-расширенный-блок)
  - [Интуиция и когда применять](#1-интуиция-и-когда-применять)
  - [Базовое дерево отрезков (только точечные)](#2-базовое-дерево-отрезков-только-точечные)
  - [Память: $2N$, $3N$, $4N$ — мифы и факты](#3-память-2n-3n-4n--мифы-и-факты)
  - [Почему иногда не хватает $3n$: контрпример](#4-почему-иногда-не-хватает-3n-контрпример)
  - [Базовые операции (функции и их назначение)](#5-базовые-операции-функции-и-их-назначение)
  - [Рекурсивная реализация + разбор функций](#6-рекурсивная-реализация--разбор-функций)
  - [Итеративная реализация bottom-up](#7-итеративная-реализация-bottom-up)
  - [Lazy propagation: add, assign, mix](#8-lazy-propagation-add-assign-mix)
  - [Advanced: минимум + счётчик, gcd, $k$-th, первая позиция по предикату](#9-advanced-минимум--счётчик-gcd-k-th-первая-позиция-по-предикату)
  - [Dynamic / Sparse / Persistent / Beats](#10-dynamic--sparse--persistent--beats)
  - [Неявное (implicit) дерево отрезков](#11-неявное-implicit-дерево-отрезков)
  - [Edge cases и как их обрабатывать](#12-edge-cases-и-как-их-обрабатывать)
  - [Сравнение с Fenwick](#13-сравнение-с-fenwick)
  - [Шаблон нейтральных элементов](#14-шаблон-нейтральных-элементов)
  - [Поиск $k$-th (подробно)](#15-поиск-k-th-подробно)
  - [Оптимизации и мелкие трюки](#16-оптимизации-и-мелкие-трюки)
  - [Частые ошибки и диагностика](#17-частые-ошибки-и-диагностика)
  - [Большой пример: комбинированные операции](#18-большой-пример-комбинированные-операции)
  - [Шпаргалка ультра-коротко](#19-шпаргалка-ультра-коротко)
  - [Цитаты для мотивации :)](#20-цитаты-для-мотивации-)

---

## Разбор задачки L (возможны неточности)
### 1. Формулировка (перефраз)
Есть неориентированный граф $G=(V,E)$, $|V|=n$, $|E|=m$, каждая вершина — монета. Известно, что ровно одна монета медная, остальные — из двух других материалов (назовём их «железо» и «бронза»). Для каждой из $m$ пар $(a_i,b_i)$ сказано: материалы различны.  
Пусть вершина $p$ — кандидат на «медь». Тогда все остальные $V\setminus\{p\}$ должны быть двудольно раскрашиваемы в два цвета (железо/бронза) так, что каждое ребро соединяет вершины разных цветов.  
Нужно найти все $p$, для которых это возможно. Эквивалентно: граф $G\setminus\{p\}$ двудольный.

### 2. Главная редукция
Вершина $p$ допустима $\Longleftrightarrow$ $G\setminus\{p\}$ не содержит нечётных циклов.  
Следовательно, $p$ допустима $\Longleftrightarrow$ каждая нечётная циклическая компонента $G$ содержит $p$.  
То есть множество ответов — пересечение всех нечётных циклов графа.  
Если нечётных циклов нет (граф уже двудольный), ответ: все вершины.

Обозначим:
- множество всех нечётных циклов: $\mathcal{C}_{odd}$;
- их пересечение: $I = \bigcap_{C\in \mathcal{C}_{odd}} C$;
- итоговый ответ: $I$ (или все вершины, если $\mathcal{C}_{odd}=\varnothing$).

### 3. Стандартный DFS и классификация рёбер
Строим DFS-лес (граф может быть несвязным):
- для каждой вершины $v$: глубина $depth(v)$ (корень компоненты имеет глубину $0$ или $1$ — не важно, лишь бы единообразно);
- классифицируем встреченные рёбра:
  - $tree$-рёбра — ведущие к непосещённым вершинам;
  - $back$-рёбра — к уже посещённым предкам (в неориентированном графе можно ограничиться ребром к предку по времени входа, условие $tin(u)>tin(v)$ и $v$ — предок).
(Рёбра к уже пройденным «не-предкам» в неориентированном не возникают как отдельная категория — каждое такое будет зеркалом «back» в другом порядке обхода.)

Обозначим время входа $tin(v)$ для фильтрации повторов и $\;parent(v)$ в дереве.

### 4. Фактор паритета
Определим паритет вершины: $parity(v)=depth(v)\bmod 2$.  
Рассмотрим $back$-ребро $(u,v)$, где $v$ — предок $u$. Пусть путь в дереве между $u$ и $v$ имеет длину $L$. Тогда соответствующий фундаментальный цикл имеет длину $L+1$.  
Цикл нечётный $\Longleftrightarrow (L+1)\bmod 2=1 \Longleftrightarrow L$ чётен $\Longleftrightarrow parity(u)=parity(v)$.

Таким образом: каждое $back$-ребро, соединяющее вершины одинакового паритета, образует один фундаментальный нечётный цикл.

### 5. Почему достаточно фундаментальных нечётных циклов
Для каждого нечётного цикла $C$ выберем его ребро, являющееся $back$-ребром в DFS (оно существует, иначе цикл был бы чисто из $tree$-рёбер — невозможно). Это $back$-ребро соединяет вершины одинакового паритета (иначе цикл был бы чётным). Соответствующий фундаментальный нечётный цикл $F$ — подмножество вершин (и рёбер) $C$.  
Если вершина $x$ содержится во всех фундаментальных нечётных циклах, то для любого нечётного $C$ она лежит в принадлежащем $C$ фундаментальном цикле $F$, следовательно $x\in C$.  
Итак:
$$
I = \bigcap_{C\in \mathcal{C}_{odd}} C = \bigcap_{F\in \mathcal{F}_{odd}} F,
$$
где $\mathcal{F}_{odd}$ — множество фундаментальных нечётных циклов ($back$-рёбра между вершинами одинакового паритета).

### 6. Задача сводится к подсчёту покрытия путей
Каждый фундаментальный нечётный цикл состоит из:
- пути в DFS-дереве между $(u,v)$ (включительно);
- самого $back$-ребра $(u,v)$ (оно не добавляет новых вершин).

Значит достаточно пометить все вершины пути между $u$ и $v$ для каждого такого $back$-ребра, подсчитать для каждой вершины $v$ число фундаментальных нечётных циклов, проходящих через неё:
- обозначим $total_{odd}$ — общее число таких $back$-рёбер;
- обозначим $cnt(v)$ — сколько раз вершина оказалась на отмеченных путях.  
Тогда:
$$
v \text{ в ответе } \Longleftrightarrow
\begin{cases}
total_{odd}=0 & \text{(граф двудолен)}\\
\text{или } cnt(v)=total_{odd} & \text{(вершина лежит во всех нечётных фундаментальных циклах)}
\end{cases}
$$

### 7. Дифференциальная маркировка путей (без обхода каждого пути целиком)
Пусть нужно «прибавить $1$» ко всем вершинам на (включительном) пути между $u$ и $v$. Обозначим $w = LCA(u,v)$ (наименьший общий предок в DFS-дереве). Корень компоненты обозначим $root$.  
Корректная разностная формула (для вершин):
- $add(u) \mathrel{+}= 1$;
- $add(v) \mathrel{+}= 1$;
- $add(w) \mathrel{-}= 1$;
- если $parent(w)$ существует, то $add(parent(w)) \mathrel{-}= 1$.

После того как все такие операции применены для всех фундаментальных нечётных циклов, выполняем один пост-обход (суммирование значений детей в родителя). Итоговое накопленное значение $sum(v)$ (равное скорректированному $add(v)$ после агрегации) и есть $cnt(v)$.

Почему работает:
- Рассмотрим дерево с направлением «вниз» от $root$. Любая вершина получает +1 от каждого пути, в котором она лежит между $u$ и $v$.
- Вычитание в $w$ и его родителе «останавливает» распространение суммы выше $w$, гарантируя включение самого $w$ (а не его предков вне пути).
- В случае $w = root$ (нет $parent(w)$) делаем только три операции.

Особые случаи:
- Если $u = v$ (например, самопетля): путь — единственная вершина; формула даёт:
  $add(u) \mathrel{+}=1$, ещё раз $add(v) \mathrel{+}=1$ (то есть $+2$), затем $add(w) \mathrel{-}=1$ (итого $+1$), и если нет родителя — всё. Получаем корректно $cnt(u)$ увеличивается на $1$.
- Если самопетли в разных вершинах: каждый даёт независимый нечётный цикл длины $1$. Пересечение всех таких циклов — пусто, если самопетли в двух разных вершинах. Это автоматически выявится: для двух самопетель в $v_1$ и $v_2$: $cnt(v_1)=1$, $cnt(v_2)=1$, $total_{odd}=2$, ни одна вершина не набирает $2$.

### 8. Обработка всех компонент
Граф может быть несвязным:
- выполняем DFS из каждой непосещённой вершины, формируем отдельное дерево;
- внутри каждой компоненты считаем $depth$, $parent$, $tin$, и обрабатываем её $back$-рёбра;
- суммирование $add$ делается по каждому корню отдельно (лес);
- $total_{odd}$ — глобально по всему графу.

Фактически $cnt(v)$ — число фундаментальных нечётных циклов (в глобальном лесу), проходящих через $v$.

### 9. Паритет и фильтрация $back$-рёбер
Для каждого кандидатного $back$-ребра $(u,v)$ (где $v$ — предок):
- Проверяем $parity(u)=parity(v)$.
- Если да — это фундаментальный нечётный цикл; применяем разностную операцию; увеличиваем $total_{odd}$.

Замечание: каждое неориентированное ребро встречается дважды в списках смежности — нужно обеспечить учёт только «вниз → вверх» (например, условие $tin(v)<tin(u)$) чтобы не удвоить цикл.

### 10. Обоснование корректности критерия ответа
Итог:
- Если $total_{odd}=0$, граф двудолен: любое удаление вершины сохраняет двудольность $\Rightarrow$ все вершины возможны.
- Иначе вершина $p$ допустима $\Longleftrightarrow$ удаление $p$ уничтожает все нечётные циклы $\Longleftrightarrow p$ лежит в пересечении всех фундаментальных нечётных циклов $\Longleftrightarrow cnt(p)=total_{odd}$.

### 11. Разбор типичных граничных случаев
1. $n=1, m=0$: нечётных циклов нет $\Rightarrow$ ответ: $\{1\}$.
2. Самопетля в единственной вершине $v$: $total_{odd}=1$, $cnt(v)=1$ $\Rightarrow$ ответ $\{v\}$.
3. Две самопетли в разных вершинах: два нечётных цикла длины $1$ без пересечения $\Rightarrow$ $cnt(v_i)=1$, $total_{odd}=2$, ответ пуст.
4. Параллельные рёбра между $u$ и $v$: цикл длины $2$ (чётный) — не влияет.
5. Несколько нечётных циклов, пересекающихся частично: формула автоматически оставляет только их общее пересечение.
6. Компонента без нечётных циклов и другая с нечётными: если хотя бы одна нечётная компонента существует, вершины из полностью двудольных компонент могут быть ответом только если они лежат во всех нечётных циклах? Но они не лежат ни в одном нечётном цикле ⇒ их $cnt=0 < total_{odd}$ ⇒ они исключаются, и это корректно: удаление вершины из «бипартитной» отдельной компоненты не удалит нечётный цикл в другой компоненте.
7. Вершина на «одних» нечётных циклах, но не на других — как в примере с циклами $(1,2,3)$ и $(0,1,3)$: $cnt(1)=cnt(3)=2$, $cnt(2)=1$, $cnt(0)=1$, $total_{odd}=2$, ответ $\{1,3\}$.

### 12. Иллюстрация (mermaid)
Пример с двумя нечётными циклами, пересечение которых состоит из двух вершин.
```mermaid
graph TD
  0 -- -- 1
  1 -- -- 2
  2 -- -- 3
  3 -- -- 1
  0 -- -- 3
  %% Нечёткие циклы: (1,2,3) и (0,1,3); пересечение = {1,3}
```

### 13. Память и масштабируемость
Ограничения: $n,m \le 3\cdot 10^6$.
- Хранение списка смежности: по два конца на ребро ⇒ $2m$ целых. При 4 байтах на число: $\approx 8m$ байт (до $\approx 24$ МБ при $m=3\cdot 10^6$) + массивы индексов, итого разумно, если использовать плотные массивы.
- Массивы размеров $n$: $depth$, $parent$, $tin$, $add$, $sum$, булевы флаги — ещё порядка нескольких десятков мегабайт.
- LCA: классический бинлифтинг требует $n \log n$; для $n=3\cdot 10^6$ и $\log_2 n \approx 22$ это $\approx 66$ млн целых ⇒ риск превышения памяти. Возможные стратегии:
  - (a) LCA через «время входа + RMQ по эйлерову проходу»: хранение эйлерова массива длины $2n$ и Sparse Table ($2n \log(2n)$) — тоже дорого;
  - (b) Онлайновый подъём без предобработки (поднимая более глубокую вершину наверх по $parent$) слишком медленный в худшем случае (длинные пути);
  - (c) Сжатие глубины: если граф «широкий», но не «глубокий», бинлифтинг дешевле;
  - (d) Альтернатива: заменить LCA на офлайн метод типа Tarjan LCA (требует запросов заранее — здесь каждое $back$-ребро инициирует один запрос; можно запускать Tarjan параллельно с DFS). Тогда не нужен бинлифтинг: память уменьшается до $O(n + m)$.

Вывод: практически для больших $n$ целесообразно использовать офлайн Tarjan LCA или аккуратно реализованный бинлифтинг с 32-битными числами.

### 14. Временная сложность
- Один проход DFS: $O(n + m)$.
- Обработка каждого $back$-ребра: $O(1)$ на классификацию + $O(1)$ на «маркировку» (четыре операции).
- LCA: 
  - бинлифтинг: подготовка $O(n \log n)$, запрос $O(\log n)$ для каждого фундаментального нечётного цикла;
  - или Tarjan LCA: суммарно $O(n + m + q)$, где $q$ — число запросов (не более числа $back$-рёбер).
- Финальное накопление по дереву(ям): $O(n)$.
Итого доминирует $O(n + m)$ при использовании Tarjan LCA или практически $O((n+m)\log n)$ при бинлифтинге.

### 15. Корректность формулы для включительного пути
Пусть $Path(u,v)$ — множество вершин на пути $u \leadsto v$. Покажем, что после операций
$$
add(u){+}{=}1,\quad add(v){+}{=}1,\quad add(w){-}{=}1,\quad add(parent(w)){-}{=}1
$$
и накопления снизу-вверх значение $sum(x)$ равно количеству путей, покрывающих $x$.
- Подъём суммы из листьев гарантирует, что $sum(x)=add(x)+\sum_{c\;child\;x} sum(c)$.
- Вклад пути в вершину $x$ не идёт выше $parent(w)$, т.к. там вычтено $1$; одновременно $w$ остаётся включённым (его итоговое изменение $+1+1-1-(1 \text{ если есть parent})$ даёт чистый $+1$).
- Любая вершина вне пути получает баланс $0$ (либо не получает инкрементов, либо +1/-1 компенсируются по ветвям).

### 16. Частые ошибки
1. Использование формулы $add(u){+}{=}1, add(v){+}{=}1, add(w){-}{=}2$ (которая корректна для подсчёта рёбер, а не вершин) — теряется $LCA$.
2. Двойной учёт одного $back$-ребра (нефильтрация по $tin$).
3. Неправильная обработка самопетель: пропуск или двойной учёт.
4. Игнорирование несвязных компонент (некорректные $parent$ / отсутствие $LCA$).
5. Ошибочный вывод при отсутствии нечётных циклов (нужно вывести все вершины).
6. Переполнение стека рекурсией при длинной цепочке (нужен итеративный DFS при больших $n$).
7. Неверное вычисление $LCA$, что искажает путь и счётчики.

### 17. Итоговая словесная схема (алгоритм без кода)
1. Инициализация структур для DFS и матрицы/механизма $LCA$ (бинлифтинг или Tarjan).
2. Для каждой непосещённой вершины запускаем DFS:
   - фиксируем $depth$, $parent$, $tin$;
   - при встрече ребра $(u,v)$:
     - если $v$ непосещён — $tree$-ребро;
     - иначе если $v$ — предок и $tin(v) < tin(u)$ — кандидат $back$-ребра:
       - проверяем $parity(u)=parity(v)$; если да:
         - находим $w=LCA(u,v)$;
         - применяем дифференциальные обновления $add$;
         - увеличиваем $total_{odd}$.
3. После полного обхода леса выполняем пост-обход(ы) для аккумуляции $add \to sum$.
4. Если $total_{odd}=0$: ответ — весь список вершин.
5. Иначе формируем множество $Ans = \{ v \mid sum(v)= total_{odd} \}$.
6. Если $Ans=\varnothing$: выводим $0$. Иначе — $|Ans|$ и отсортированные вершины (при необходимости сортировки; порядок обхода дерева не гарантирует глобальной отсортированности).
7. (Опционально) Проверяем особые тривиальные случаи заранее (самопетли в разных вершинах).

### 18. Резюме
- Задача сводится к пересечению всех нечётных циклов.
- Достаточно рассматривать фундаментальные нечётные циклы из $back$-рёбер одинакового паритета глубин.
- Маркировка путей делается дифференциально через $u$, $v$, $LCA(u,v)$ и $parent(LCA)$.
- Вершины с $cnt(v)=total_{odd}$ образуют искомое пересечение.
- В отсутствии нечётных циклов все вершины допустимы.

---

## Дерево отрезков (Segment Tree) — расширенный блок

> «Дерево отрезков — это как швейцарский нож: 90% задач ты решишь стандартным лезвием $(sum\ /\ min)$, остальные 10% — добор насадок $(lazy, beats, persist)$.»

### 1. Интуиция и когда применять
Хотим быстро отвечать на запросы вида «агрегат по подотрезку» + вносить изменения. Если нужны: сумма, минимум, максимум, $gcd$, первый индекс с условием, подсчёт кол-ва элементов, частота — это сюда.  
Если операции коммутативные и только $prefix$ → можно $Fenwick$. Если нужны сложные кастомные merge или несколько типов обновлений — $Segment\ Tree$.

### 2. Базовое дерево отрезков (только точечные)
Самый первый слой: поддерживаем массив длины $n$, умеем:
1. Построить дерево за $O(n)$.
2. Сделать точечное присваивание/прибавление.
3. Получить агрегат (например, сумму) на любом $[l,r]$.

Без ленивых меток мы работаем только с путём от листа к корню: глубина $\approx \lceil \log_2 n \rceil$.

Когда хватает базового варианта:
- много точечных апдейтов, мало диапазонных;
- или диапазоны маленькие (можно разбить на точки без боли);
- задача «подсчитать сумму по префиксу/отрезку» + «обновить элемент».

### 3. Память: $2N$, $3N$, $4N$ — мифы и факты
Повторим и усилим:
— Итеративно: берём $N = 2^{\lceil \log_2 n \rceil}$ → размер массива $2N$ (листья в $[N,2N)$).  
— Рекурсивно: $4n$ — тупо, надёжно, не думаем.
— Почему не $3n$? Потому что может встретиться $n$ чуть больше половины степени двойки и тогда нужно почти удвоить число листьев.
Формула грубо: число узлов полного двоичного дерева $\le 2\cdot 2^{\lceil \log_2 n \rceil}$.  
Если нужна экономия — итеративный вариант.

### 4. Почему иногда не хватает $3n$: контрпример
Возьмём $n = 2^{k-1}+1$. Тогда $\lceil \log_2 n \rceil = k$ и $N = 2^k$.  
Число узлов у полного дерева: $2N - 1 = 2^{k+1}-1$.  
Отношение к $n$:
$\frac{2^{k+1}-1}{2^{k-1}+1} = \frac{4\cdot 2^{k-1}-1}{2^{k-1}+1} \approx 4 - \frac{5}{2^{k-1}+1}.$  
При большом $k$ отношение стремится к $4$. Значит нужно почти $4n$ узлов; $3n$ объективно недостаточно — вот «то самое дерево», которое «не влезает в $3n$».

Мини-числовой пример: $n=9$. Тогда $N=16$, узлов $=31$. $3n=27 < 31$ → действительно мало.

### 5. Базовые операции (функции и их назначение)
| Функция | Назначение | Критично помнить |
|---------|------------|------------------|
| $build$   | Построение агрегатов снизу вверх | $O(n)$ итеративно; рекурсивно тоже $O(n)$ |
| $query$   | Сбор результата по покрывающим сегментам | Возвращает $NEUTRAL$ на пустом пересечении |
| $\text{update (point)}$ | Изменить лист и пересчитать путь вверх | $Высота ≈ log (n)$ |
| $\text{range\_update (lazy)}$ | Массово изменить интервал | Не спускаемся полностью, ставим метки |
| $\text{push}$    | Проталкивание ленивых меток вниз | Вызывать перед частичным разбиением |
| $\text{apply}$   | Применение метки к узлу | Корректно менять агрегат и накапливать флаг |
| $\text{merge}$   | Комбинация двух детей | Ассоциативность обязательна |

### 6. Рекурсивная реализация + разбор функций
```cpp
struct SegBasic {
  struct Node { long long sum = 0; }; // можно расширить
  int n; vector<Node> st;
  SegBasic(int n): n(n), st(4*n) {}
  template<class Arr>
  void build(int v,int tl,int tr,const Arr& a){
    if(tl==tr){ st[v].sum = a[tl]; return; }
    int tm=(tl+tr)>>1;
    build(v<<1, tl, tm, a);
    build(v<<1|1, tm+1, tr, a);
    st[v].sum = st[v<<1].sum + st[v<<1|1].sum; // merge
  }
  void point_set(int v,int tl,int tr,int pos,long long val){
    if(tl==tr){ st[v].sum = val; return; }
    int tm=(tl+tr)>>1;
    if(pos<=tm) point_set(v<<1, tl, tm, pos, val);
    else        point_set(v<<1|1, tm+1, tr, pos, val);
    st[v].sum = st[v<<1].sum + st[v<<1|1].sum;
  }
  long long range_sum(int v,int tl,int tr,int l,int r){
    if(l>r) return 0; // NEUTRAL
    if(l==tl && r==tr) return st[v].sum;
    int tm=(tl+tr)>>1;
    return range_sum(v<<1, tl, tm, l, min(r, tm)) +
         range_sum(v<<1|1, tm+1, tr, max(l, tm+1), r);
  }
};
```
Пояснения: 
- $NEUTRAL$ для суммы — 0; для минимума взяли бы $+\infty$.  
- Любой выход за границы возвращает $NEUTRAL$.

### 7. Итеративная реализация bottom-up
```cpp
struct SegIter {
  int N; vector<long long> t; // t[1] — корень, листья в [N,2N)
  SegIter(int n){ N=1; while(N<n) N<<=1; t.assign(2*N, 0); }
  template<class Arr>
  void build(const Arr& a){
    for(size_t i=0;i<a.size();++i) t[N+i]=a[i];
    for(int v=N-1; v>0; --v) t[v]=t[v<<1]+t[v<<1|1];
  }
  void point_set(int pos,long long val){
    int v = N+pos; t[v]=val; v>>=1;
    while(v){ t[v]=t[v<<1]+t[v<<1|1]; v>>=1; }
  }
  long long range_sum(int l,int r){
    long long res=0; l+=N; r+=N;
    while(l<=r){
      if(l&1) res+=t[l++];
      if(!(r&1)) res+=t[r--];
      l>>=1; r>>=1;
    }
    return res;
  }
};
```
Фишка: нет рекурсии, минимальные константы — топ для интенсивных запросов.

### 8. Lazy propagation: add, assign, mix
Рассмотрим наиболее частые комбинации.

#### (a) Только диапазонное добавление + сумма
```cpp
struct SegLazyAdd {
  struct Node { long long sum=0, add=0; };
  int n; vector<Node> st;
  SegLazyAdd(int n): n(n), st(4*n) {}
  template<class A>
  void build(int v,int tl,int tr,const A& a){
    if(tl==tr){ st[v].sum=a[tl]; return; }
    int tm=(tl+tr)>>1; build(v<<1,tl,tm,a); build(v<<1|1,tm+1,tr,a);
    st[v].sum = st[v<<1].sum + st[v<<1|1].sum;
  }
  void apply(int v,int tl,int tr,long long add){
    st[v].sum += (tr-tl+1)*add;
    st[v].add += add;
  }
  void push(int v,int tl,int tr){
    if(st[v].add==0 || tl==tr) return; int tm=(tl+tr)>>1;
    apply(v<<1, tl, tm, st[v].add);
    apply(v<<1|1, tm+1, tr, st[v].add);
    st[v].add=0;
  }
  void range_add(int v,int tl,int tr,int l,int r,long long x){
    if(l>r) return; if(l==tl && r==tr){ apply(v,tl,tr,x); return; }
    push(v,tl,tr); int tm=(tl+tr)>>1;
    range_add(v<<1,tl,tm,l,min(r,tm),x);
    range_add(v<<1|1,tm+1,tr,max(l,tm+1),r,x);
    st[v].sum = st[v<<1].sum + st[v<<1|1].sum;
  }
  long long range_sum(int v,int tl,int tr,int l,int r){
    if(l>r) return 0; if(l==tl && r==tr) return st[v].sum;
    push(v,tl,tr); int tm=(tl+tr)>>1;
    return range_sum(v<<1,tl,tm,l,min(r,tm)) +
         range_sum(v<<1|1,tm+1,tr,max(l,tm+1),r);
  }
};
```

#### (b) Диапазонное присваивание (assign) + добавление + сумма
В узле надо хранить: $sum$, $add$, $hasAssign$, $assignVal$. Порядок push: если есть pending assign — сначала проталкиваем его, и только потом add.
```cpp
struct SegLazyAssignAdd {
  struct Node { long long sum=0, add=0, assignVal=0; bool hasAssign=false; };
  int n; vector<Node> st;
  SegLazyAssignAdd(int n): n(n), st(4*n) {}
  void build(int v,int tl,int tr,const vector<long long>& a){
    if(tl==tr){ st[v].sum=a[tl]; return; }
    int tm=(tl+tr)>>1; build(v<<1,tl,tm,a); build(v<<1|1,tm+1,tr,a);
    st[v].sum = st[v<<1].sum + st[v<<1|1].sum;
  }
  void applyAssign(int v,int tl,int tr,long long val){
    st[v].sum = (tr-tl+1)*val;
    st[v].assignVal = val; st[v].hasAssign = true; st[v].add = 0;
  }
  void applyAdd(int v,int tl,int tr,long long x){
    st[v].sum += (tr-tl+1)*x;
    if(st[v].hasAssign) st[v].assignVal += x; else st[v].add += x;
  }
  void push(int v,int tl,int tr){
    if(tl==tr) return; int tm=(tl+tr)>>1;
    if(st[v].hasAssign){
      applyAssign(v<<1, tl, tm, st[v].assignVal);
      applyAssign(v<<1|1, tm+1, tr, st[v].assignVal);
      st[v].hasAssign=false;
    }
    if(st[v].add){
      applyAdd(v<<1, tl, tm, st[v].add);
      applyAdd(v<<1|1, tm+1, tr, st[v].add);
      st[v].add=0;
    }
  }
  void range_assign(int v,int tl,int tr,int l,int r,long long val){
    if(l>r) return; if(l==tl && r==tr){ applyAssign(v,tl,tr,val); return; }
    push(v,tl,tr); int tm=(tl+tr)>>1;
    range_assign(v<<1,tl,tm,l,min(r,tm),val);
    range_assign(v<<1|1,tm+1,tr,max(l,tm+1),r,val);
    st[v].sum = st[v<<1].sum + st[v<<1|1].sum;
  }
  void range_add(int v,int tl,int tr,int l,int r,long long x){
    if(l>r) return; if(l==tl && r==tr){ applyAdd(v,tl,tr,x); return; }
    push(v,tl,tr); int tm=(tl+tr)>>1;
    range_add(v<<1,tl,tm,l,min(r,tm),x);
    range_add(v<<1|1,tm+1,tr,max(l,tm+1),r,x);
    st[v].sum = st[v<<1].sum + st[v<<1|1].sum;
  }
  long long range_sum(int v,int tl,int tr,int l,int r){
    if(l>r) return 0; if(l==tl && r==tr) return st[v].sum;
    push(v,tl,tr); int tm=(tl+tr)>>1;
    return range_sum(v<<1,tl,tm,l,min(r,tm)) +
         range_sum(v<<1|1,tm+1,tr,max(l,tm+1),r);
  }
};
```

### 9. Advanced: минимум + счётчик, gcd, k-th, первая позиция по предикату
1. $(min,\ countMin)$: храним $mn$, $cnt$. merge: выбираем меньший $mn$, если равны — складываем $cnt$.
2. $gcd$: merge = $gcd(left, right)$; $NEUTRAL = 0$.
3. $k$-th по суммам: если `sum(left) >= k` → влево, иначе `k -= sum(left)` и вправо.
4. Первая позиция с `sumPrefix >= X` — аналогично $k$-th.
5. Первое место где $mn < 0$ — спускаемся только если $node.mn < 0$.

### 10. Dynamic / Sparse / Persistent / Beats
| Вид | Где нужен | Суть |
|-----|-----------|------|
| $Dynamic$ | Большой диапазон (до $1e18$) c малым числом точек | Узлы создаём по требованию (указатели / индекс-пул) |
| $Persistent$ | Нужны версии по времени (immutable) | Каждый update копирует путь до корня ($O(log (n))$ новых узлов) |
| $Sparse$ (коорд. компрессия) | Большие координаты, известны заранее точки | Сжимаем и строим обычное дерево |
| $Beats$ | Операции типа $chmin\ /\ chmax$ + запрос суммы/макс/мин | Храним $max1,\ max2,\ cntMax$ и т.п., проталкиваем умно |

### 11. Неявное (implicit) дерево отрезков
Иногда диапазон индексов огромный (например, координаты до $10^{18}$), но реально используемых позиций мало. Тогда мы не можем выделить массив на $N = 2^{\lceil \log_2 n \rceil}$. Решение — неявное (implicit) ДО: создаём узлы на лету, когда до них доходим.

Простейшая версия для суммы точечных обновлений:
```cpp
struct Node {
  long long sum=0; Node *L=nullptr,*R=nullptr;
};
const long long MINX = 0, MAXX = (1LL<<60); // адаптировать под диапазон

void point_add(Node*& v,long long tl,long long tr,long long pos,long long val){
  if(!v) v=new Node();
  if(tl==tr){ v->sum += val; return; }
  long long tm=(tl+tr)>>1;
  if(pos<=tm) point_add(v->L,tl,tm,pos,val);
  else point_add(v->R,tm+1,tr,pos,val);
  long long leftSum = v->L? v->L->sum:0;
  long long rightSum= v->R? v->R->sum:0;
  v->sum = leftSum + rightSum;
}

long long range_sum(Node* v,long long tl,long long tr,long long l,long long r){
  if(!v || l>r) return 0;
  if(l==tl && r==tr) return v->sum;
  long long tm=(tl+tr)>>1;
  return range_sum(v->L,tl,tm,l,min(r,tm)) +
       range_sum(v->R,tm+1,tr,max(l,tm+1),r);
}
```
Плюсы: память пропорциональна числу реально обновлённых позиций ($O(m \log R)$ узлов максимум). Минусы: указатели, аллокации, хуже константы.

Можно расширить до lazy для диапазонных операций — храним метку в узле, создаём детей только когда нужно push.

### 12. Edge cases и как их обрабатывать
| Ситуация | Проблема | Решение |
|----------|----------|---------|
| $n=1$ | Границы, $tl==tr$ | Просто возвращаем лист |
| Запрос вне диапазона | $l>r$ | Возвращаем $NEUTRAL$ | 
| Переполнение суммы | $int\ overflow$ | $long\ long$ + осторожно с $(tr-tl+1)*val$ |
| Все элементы одинаковы | проверка обновлений | Должно корректно пересчитаться (не кэшировать вне узлов) |
| $assign + add$ | порядок | Сначала $assign$ (перезаписывает), затем $add$ |
| Много версий (persistent) | Память | Пул узлов + шаринг неизменённых |
| Очень глубокая рекурсия | $Stack\ overflow$ | Итеративный или свой стек |
| $Lazy$ забыли $push$ | Неверный ответ | Всегда $push$ при частичном покрытии |
| $k$-th не существует | выход за суммарную сумму | Проверять $k<=totalSum$ заранее |
| $gcd$ с нулями | $gcd(0,x)=x$ | Ок — это и есть $NEUTRAL$ |

### 13. Сравнение с Fenwick
| Критерий | Segment Tree | Fenwick |
|----------|--------------|---------|
| Память | $2N$ или $4N$ | $N$ |
| Гибкость | Любые ассоц. $merge + сложный\ lazy$ | Почти только + / $XOR$ / $prefix$ |
| $Range\ assign$ | $Lazy\ просто$ | Сложно (двойной $Fenwick$ только для разностей) |
| $k$-th | Да | Да (по префиксной сумме) |
| $Beats$ / сложные операции | Да | Нет |

### 14. Шаблон нейтральных элементов
| Операция | $merge$ | $NEUTRAL$ |
|----------|-------|---------|
| sum | $a+b$ | $0$ |
| min | $min(a,b)$ | $+\infty$ |
| max | $max(a,b)$ | $-\infty$ |
| gcd | $gcd(a,b)$ | $0$ |
| xor | $a \oplus b$ | $0$ |
| (mn,cnt) | $min$ по $mn$ + $sum$ $cnt$ | $(+\infty,0)$ |

### 15. Поиск k-th (подробно)
Алгоритм (рекурсивно):
1. Если $tl==tr$ → вернуть $tl$.
2. Пусть $left$ = сумма левого сына.
3. Если $k <= left$ → влево, иначе $k-left$ → вправо.
Итеративно: идём от корня, пока не достигли листа. Работает только если все значения неотрицательны (иначе префиксная монотонность ломается).

### 16. Оптимизации и мелкие трюки
- Сбрасывать вектор через $assign$ быстрее чем $resize$ в некоторых случаях.
- Для speed: пометить функции $inline$, включить `-O2 -march=native`.
- Использовать `__builtin_clz` чтобы быстро получить $ceil\_pow2$.
- В итеративной версии можно хранить «ленивые» метки отдельно и проталкивать при подъёме (требует аккуратности).
- Композиция операций: для ($assign,\ add$) метка-композиция — если новая $assign$ приходит поверх $add$, $add$ обнуляется.

### 17. Частые ошибки и диагностика
| Симптом | Возможная причина | Как проверить |
|---------|------------------|---------------|
| Ответ случайно больше/меньше | Не протолкнули lazy | Логирование push вызовов |
| Виснет / $TLE$ | Рекурсия + $n≈2e5$ + слабый компилятор | Перейти на итеративный |
| Негативные значения ломают $k$-th | Предполагали монотонность | Добавить проверку или хранить $prefix$ отдельно |
| $Память > лимит$ | $4n$*несколько деревьев | Совместить/удалить лишнее, перейти на итеративный |
| Неверные $gcd$ | $NEUTRAL ≠ 0$ | Исправить NEUTRAL |

### 18. Большой пример: комбинированные операции
Задача: поддерживать массив с операциями: $1\ l\ r\ add\ x$, $2\ l\ r\ assign\ x$, $3\ l\ r\ query\ sum$, $4\ l\ r\ query\ min$.
Подход: Храним для узла: $sum$, $mn$, $add$, $assign$, $hasAssign$. 

При применении:
```
applyAssign: sum = len*val; mn = val; assignVal=val; hasAssign=true; add=0
applyAdd: sum += len*x; mn += x; if(hasAssign) assignVal+=x; else add+=x
push: если hasAssign → вниз assign; затем если add → вниз add
```
Запрос min и sum используют одинаковое дерево — переиспользование состояния.

### 19. Шпаргалка ультра-коротко
```
size: 2N или 4n
build: O(n)
point / range (lazy): O(log n)
NEUTRAL sum=0, min=+INF, max=-INF, gcd=0
lazy: apply + push (очистить флаг после проталкивания)
assign + add: порядок = assign -> add
k-th: спуск по суммам (неотрицательные)
dynamic: узлы по требованию
persistent: копируем путь
beats: сложные chmin/chmax
```

### 20. Цитаты для мотивации :octocat:
> «Если решение не укладывается в структуру данных, расширь структуру».  
> «Segment Tree — это когда лень писать Mo и хочется логарифмы».  
> «Каждый забытый push — минус 30 минут дебага».

---
Если заметил неточность — стукни: перепишу после того как перестанет звенеть в голове. - Vadim Khristenko, 2025



# Конспект от 04.10.2025 | Параллель B
## Тема: Древо отрезков и его применение

> Автор: Вадим Христенкко  
> Дружеский конспект — просто и понятно о сложных вещах.  
> Разбор задачек будет потом отдельно в другом файле заисключением последних двух задач.  
> Они будут разобраны здесь же.

# Разбор задачки L | Возможны неточности.
## 1. Формулировка (перефраз)
Есть неориентированный граф $G=(V,E)$, $|V|=n$, $|E|=m$, каждая вершина — монета. Известно, что ровно одна монета медная, остальные — из двух других материалов (назовём их «железо» и «бронза»). Для каждой из $m$ пар $(a_i,b_i)$ сказано: материалы различны.  
Пусть вершина $p$ — кандидат на «медь». Тогда все остальные $V\setminus\{p\}$ должны быть двудольно раскрашиваемы в два цвета (железо/бронза) так, что каждое ребро соединяет вершины разных цветов.  
Нужно найти все $p$, для которых это возможно. Эквивалентно: граф $G\setminus\{p\}$ двудольный.

## 2. Главная редукция
Вершина $p$ допустима $\Longleftrightarrow$ $G\setminus\{p\}$ не содержит нечётных циклов.  
Следовательно, $p$ допустима $\Longleftrightarrow$ каждая нечётная циклическая компонента $G$ содержит $p$.  
То есть множество ответов — пересечение всех нечётных циклов графа.  
Если нечётных циклов нет (граф уже двудольный), ответ: все вершины.

Обозначим:
- множество всех нечётных циклов: $\mathcal{C}_{odd}$;
- их пересечение: $I = \bigcap_{C\in \mathcal{C}_{odd}} C$;
- итоговый ответ: $I$ (или все вершины, если $\mathcal{C}_{odd}=\varnothing$).

## 3. Стандартный DFS и классификация рёбер
Строим DFS-лес (граф может быть несвязным):
- для каждой вершины $v$: глубина $depth(v)$ (корень компоненты имеет глубину $0$ или $1$ — не важно, лишь бы единообразно);
- классифицируем встреченные рёбра:
  - $tree$-рёбра — ведущие к непосещённым вершинам;
  - $back$-рёбра — к уже посещённым предкам (в неориентированном графе можно ограничиться ребром к предку по времени входа, условие $tin(u)>tin(v)$ и $v$ — предок).
(Рёбра к уже пройденным «не-предкам» в неориентированном не возникают как отдельная категория — каждое такое будет зеркалом «back» в другом порядке обхода.)

Обозначим время входа $tin(v)$ для фильтрации повторов и $\;parent(v)$ в дереве.

## 4. Фактор паритета
Определим паритет вершины: $parity(v)=depth(v)\bmod 2$.  
Рассмотрим $back$-ребро $(u,v)$, где $v$ — предок $u$. Пусть путь в дереве между $u$ и $v$ имеет длину $L$. Тогда соответствующий фундаментальный цикл имеет длину $L+1$.  
Цикл нечётный $\Longleftrightarrow (L+1)\bmod 2=1 \Longleftrightarrow L$ чётен $\Longleftrightarrow parity(u)=parity(v)$.

Таким образом: каждое $back$-ребро, соединяющее вершины одинакового паритета, образует один фундаментальный нечётный цикл.

## 5. Почему достаточно фундаментальных нечётных циклов
Для каждого нечётного цикла $C$ выберем его ребро, являющееся $back$-ребром в DFS (оно существует, иначе цикл был бы чисто из $tree$-рёбер — невозможно). Это $back$-ребро соединяет вершины одинакового паритета (иначе цикл был бы чётным). Соответствующий фундаментальный нечётный цикл $F$ — подмножество вершин (и рёбер) $C$.  
Если вершина $x$ содержится во всех фундаментальных нечётных циклах, то для любого нечётного $C$ она лежит в принадлежащем $C$ фундаментальном цикле $F$, следовательно $x\in C$.  
Итак:
$$
I = \bigcap_{C\in \mathcal{C}_{odd}} C = \bigcap_{F\in \mathcal{F}_{odd}} F,
$$
где $\mathcal{F}_{odd}$ — множество фундаментальных нечётных циклов ($back$-рёбра между вершинами одинакового паритета).

## 6. Задача сводится к подсчёту покрытия путей
Каждый фундаментальный нечётный цикл состоит из:
- пути в DFS-дереве между $(u,v)$ (включительно);
- самого $back$-ребра $(u,v)$ (оно не добавляет новых вершин).

Значит достаточно пометить все вершины пути между $u$ и $v$ для каждого такого $back$-ребра, подсчитать для каждой вершины $v$ число фундаментальных нечётных циклов, проходящих через неё:
- обозначим $total_{odd}$ — общее число таких $back$-рёбер;
- обозначим $cnt(v)$ — сколько раз вершина оказалась на отмеченных путях.  
Тогда:
$$
v \text{ в ответе } \Longleftrightarrow
\begin{cases}
total_{odd}=0 & \text{(граф двудолен)}\\
\text{или } cnt(v)=total_{odd} & \text{(вершина лежит во всех нечётных фундаментальных циклах)}
\end{cases}
$$

## 7. Дифференциальная маркировка путей (без обхода каждого пути целиком)
Пусть нужно «прибавить $1$» ко всем вершинам на (включительном) пути между $u$ и $v$. Обозначим $w = LCA(u,v)$ (наименьший общий предок в DFS-дереве). Корень компоненты обозначим $root$.  
Корректная разностная формула (для вершин):
- $add(u) \mathrel{+}= 1$;
- $add(v) \mathrel{+}= 1$;
- $add(w) \mathrel{-}= 1$;
- если $parent(w)$ существует, то $add(parent(w)) \mathrel{-}= 1$.

После того как все такие операции применены для всех фундаментальных нечётных циклов, выполняем один пост-обход (суммирование значений детей в родителя). Итоговое накопленное значение $sum(v)$ (равное скорректированному $add(v)$ после агрегации) и есть $cnt(v)$.

Почему работает:
- Рассмотрим дерево с направлением «вниз» от $root$. Любая вершина получает +1 от каждого пути, в котором она лежит между $u$ и $v$.
- Вычитание в $w$ и его родителе «останавливает» распространение суммы выше $w$, гарантируя включение самого $w$ (а не его предков вне пути).
- В случае $w = root$ (нет $parent(w)$) делаем только три операции.

Особые случаи:
- Если $u = v$ (например, самопетля): путь — единственная вершина; формула даёт:
  $add(u) \mathrel{+}=1$, ещё раз $add(v) \mathrel{+}=1$ (то есть $+2$), затем $add(w) \mathrel{-}=1$ (итого $+1$), и если нет родителя — всё. Получаем корректно $cnt(u)$ увеличивается на $1$.
- Если самопетли в разных вершинах: каждый даёт независимый нечётный цикл длины $1$. Пересечение всех таких циклов — пусто, если самопетли в двух разных вершинах. Это автоматически выявится: для двух самопетель в $v_1$ и $v_2$: $cnt(v_1)=1$, $cnt(v_2)=1$, $total_{odd}=2$, ни одна вершина не набирает $2$.

## 8. Обработка всех компонент
Граф может быть несвязным:
- выполняем DFS из каждой непосещённой вершины, формируем отдельное дерево;
- внутри каждой компоненты считаем $depth$, $parent$, $tin$, и обрабатываем её $back$-рёбра;
- суммирование $add$ делается по каждому корню отдельно (лес);
- $total_{odd}$ — глобально по всему графу.

Фактически $cnt(v)$ — число фундаментальных нечётных циклов (в глобальном лесу), проходящих через $v$.

## 9. Паритет и фильтрация $back$-рёбер
Для каждого кандидатного $back$-ребра $(u,v)$ (где $v$ — предок):
- Проверяем $parity(u)=parity(v)$.
- Если да — это фундаментальный нечётный цикл; применяем разностную операцию; увеличиваем $total_{odd}$.

Замечание: каждое неориентированное ребро встречается дважды в списках смежности — нужно обеспечить учёт только «вниз → вверх» (например, условие $tin(v)<tin(u)$) чтобы не удвоить цикл.

## 10. Обоснование корректности критерия ответа
Итог:
- Если $total_{odd}=0$, граф двудолен: любое удаление вершины сохраняет двудольность $\Rightarrow$ все вершины возможны.
- Иначе вершина $p$ допустима $\Longleftrightarrow$ удаление $p$ уничтожает все нечётные циклы $\Longleftrightarrow p$ лежит в пересечении всех фундаментальных нечётных циклов $\Longleftrightarrow cnt(p)=total_{odd}$.

## 11. Разбор типичных граничных случаев
1. $n=1, m=0$: нечётных циклов нет $\Rightarrow$ ответ: $\{1\}$.
2. Самопетля в единственной вершине $v$: $total_{odd}=1$, $cnt(v)=1$ $\Rightarrow$ ответ $\{v\}$.
3. Две самопетли в разных вершинах: два нечётных цикла длины $1$ без пересечения $\Rightarrow$ $cnt(v_i)=1$, $total_{odd}=2$, ответ пуст.
4. Параллельные рёбра между $u$ и $v$: цикл длины $2$ (чётный) — не влияет.
5. Несколько нечётных циклов, пересекающихся частично: формула автоматически оставляет только их общее пересечение.
6. Компонента без нечётных циклов и другая с нечётными: если хотя бы одна нечётная компонента существует, вершины из полностью двудольных компонент могут быть ответом только если они лежат во всех нечётных циклах? Но они не лежат ни в одном нечётном цикле ⇒ их $cnt=0 < total_{odd}$ ⇒ они исключаются, и это корректно: удаление вершины из «бипартитной» отдельной компоненты не удалит нечётный цикл в другой компоненте.
7. Вершина на «одних» нечётных циклах, но не на других — как в примере с циклами $(1,2,3)$ и $(0,1,3)$: $cnt(1)=cnt(3)=2$, $cnt(2)=1$, $cnt(0)=1$, $total_{odd}=2$, ответ $\{1,3\}$.

## 12. Иллюстрация (mermaid)
Пример с двумя нечётными циклами, пересечение которых состоит из двух вершин.
```mermaid
graph TD
  0 -- -- 1
  1 -- -- 2
  2 -- -- 3
  3 -- -- 1
  0 -- -- 3
  %% Нечёткие циклы: (1,2,3) и (0,1,3); пересечение = {1,3}
```

## 13. Память и масштабируемость
Ограничения: $n,m \le 3\cdot 10^6$.
- Хранение списка смежности: по два конца на ребро ⇒ $2m$ целых. При 4 байтах на число: $\approx 8m$ байт (до $\approx 24$ МБ при $m=3\cdot 10^6$) + массивы индексов, итого разумно, если использовать плотные массивы.
- Массивы размеров $n$: $depth$, $parent$, $tin$, $add$, $sum$, булевы флаги — ещё порядка нескольких десятков мегабайт.
- LCA: классический бинлифтинг требует $n \log n$; для $n=3\cdot 10^6$ и $\log_2 n \approx 22$ это $\approx 66$ млн целых ⇒ риск превышения памяти. Возможные стратегии:
  - (a) LCA через «время входа + RMQ по эйлерову проходу»: хранение эйлерова массива длины $2n$ и Sparse Table ($2n \log(2n)$) — тоже дорого;
  - (b) Онлайновый подъём без предобработки (поднимая более глубокую вершину наверх по $parent$) слишком медленный в худшем случае (длинные пути);
  - (c) Сжатие глубины: если граф «широкий», но не «глубокий», бинлифтинг дешевле;
  - (d) Альтернатива: заменить LCA на офлайн метод типа Tarjan LCA (требует запросов заранее — здесь каждое $back$-ребро инициирует один запрос; можно запускать Tarjan параллельно с DFS). Тогда не нужен бинлифтинг: память уменьшается до $O(n + m)$.

Вывод: практически для больших $n$ целесообразно использовать офлайн Tarjan LCA или аккуратно реализованный бинлифтинг с 32-битными числами.

## 14. Временная сложность
- Один проход DFS: $O(n + m)$.
- Обработка каждого $back$-ребра: $O(1)$ на классификацию + $O(1)$ на «маркировку» (четыре операции).
- LCA: 
  - бинлифтинг: подготовка $O(n \log n)$, запрос $O(\log n)$ для каждого фундаментального нечётного цикла;
  - или Tarjan LCA: суммарно $O(n + m + q)$, где $q$ — число запросов (не более числа $back$-рёбер).
- Финальное накопление по дереву(ям): $O(n)$.
Итого доминирует $O(n + m)$ при использовании Tarjan LCA или практически $O((n+m)\log n)$ при бинлифтинге.

## 15. Корректность формулы для включительного пути
Пусть $Path(u,v)$ — множество вершин на пути $u \leadsto v$. Покажем, что после операций
$$
add(u){+}{=}1,\quad add(v){+}{=}1,\quad add(w){-}{=}1,\quad add(parent(w)){-}{=}1
$$
и накопления снизу-вверх значение $sum(x)$ равно количеству путей, покрывающих $x$.
- Подъём суммы из листьев гарантирует, что $sum(x)=add(x)+\sum_{c\;child\;x} sum(c)$.
- Вклад пути в вершину $x$ не идёт выше $parent(w)$, т.к. там вычтено $1$; одновременно $w$ остаётся включённым (его итоговое изменение $+1+1-1-(1 \text{ если есть parent})$ даёт чистый $+1$).
- Любая вершина вне пути получает баланс $0$ (либо не получает инкрементов, либо +1/-1 компенсируются по ветвям).

## 16. Частые ошибки
1. Использование формулы $add(u){+}{=}1, add(v){+}{=}1, add(w){-}{=}2$ (которая корректна для подсчёта рёбер, а не вершин) — теряется $LCA$.
2. Двойной учёт одного $back$-ребра (нефильтрация по $tin$).
3. Неправильная обработка самопетель: пропуск или двойной учёт.
4. Игнорирование несвязных компонент (некорректные $parent$ / отсутствие $LCA$).
5. Ошибочный вывод при отсутствии нечётных циклов (нужно вывести все вершины).
6. Переполнение стека рекурсией при длинной цепочке (нужен итеративный DFS при больших $n$).
7. Неверное вычисление $LCA$, что искажает путь и счётчики.

## 17. Итоговая словесная схема (алгоритм без кода)
1. Инициализация структур для DFS и матрицы/механизма $LCA$ (бинлифтинг или Tarjan).
2. Для каждой непосещённой вершины запускаем DFS:
   - фиксируем $depth$, $parent$, $tin$;
   - при встрече ребра $(u,v)$:
     - если $v$ непосещён — $tree$-ребро;
     - иначе если $v$ — предок и $tin(v) < tin(u)$ — кандидат $back$-ребра:
       - проверяем $parity(u)=parity(v)$; если да:
         - находим $w=LCA(u,v)$;
         - применяем дифференциальные обновления $add$;
         - увеличиваем $total_{odd}$.
3. После полного обхода леса выполняем пост-обход(ы) для аккумуляции $add \to sum$.
4. Если $total_{odd}=0$: ответ — весь список вершин.
5. Иначе формируем множество $Ans = \{ v \mid sum(v)= total_{odd} \}$.
6. Если $Ans=\varnothing$: выводим $0$. Иначе — $|Ans|$ и отсортированные вершины (при необходимости сортировки; порядок обхода дерева не гарантирует глобальной отсортированности).
7. (Опционально) Проверяем особые тривиальные случаи заранее (самопетли в разных вершинах).

## 18. Резюме
- Задача сводится к пересечению всех нечётных циклов.
- Достаточно рассматривать фундаментальные нечётные циклы из $back$-рёбер одинакового паритета глубин.
- Маркировка путей делается дифференциально через $u$, $v$, $LCA(u,v)$ и $parent(LCA)$.
- Вершины с $cnt(v)=total_{odd}$ образуют искомое пересечение.
- В отсутствии нечётных циклов все вершины допустимы.


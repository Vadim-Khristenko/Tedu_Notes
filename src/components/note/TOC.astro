---
const Self = Astro.self;

const { headings } = Astro.props;
---

<style lang="less">
ul {
	margin: 0;
	padding: 0;
	list-style: none;
	font-size: 0.95rem;

	a {
		display: inline-block;
		color: var(--weak-color);
		line-height: 1.6;
		padding: 0.22rem 0.4rem;
		border-radius: 6px;
		transition: color 0.15s ease, background-color 0.12s ease, transform 0.12s ease;
	}

	a:hover,
	& > li.indicate > a {
		color: var(--primary-color);
		background: color-mix(in oklab, var(--primary-color) 6%, transparent);
		transform: translateX(3px);
		font-weight: 600;
	}

	li {
		position: relative;
		margin: 0.18rem 0;
		padding-left: 1.35rem;

		&::before {
			/* small dot marker */
			content: "";
			position: absolute;
			left: 0.4rem;
			top: 0.9rem;
			transform: translateY(-50%);
			width: 8px;
			height: 8px;
			border-radius: 50%;
			background: color-mix(in oklab, var(--remark-color) 55%, transparent);
			transition: transform 0.12s ease, background 0.12s ease, box-shadow 0.12s ease;
		}

		&.indicate::before {
			transform: scale(1.25) translateY(-50%);
			background: var(--primary-color);
			box-shadow: 0 4px 14px color-mix(in oklab, var(--primary-color) 30%, transparent);
		}

		/* vertical line for nested structure */
		&::after {
			content: "";
			position: absolute;
			left: 0.75rem;
			top: 1.6rem;
			bottom: 0.15rem;
			width: 2px;
			background: linear-gradient(to bottom, color-mix(in oklab, var(--remark-color) 40%, transparent), transparent);
			opacity: 0.6;
			border-radius: 2px;
		}

		&:last-child::after { bottom: 0.9rem; }
	}

	/* nested lists: slightly indented and lighter spacing */
	ul {
		margin-top: 0.25rem;
		margin-left: 0.25rem;
		padding-left: 0;
	}

	a:focus {
		outline: 2px solid color-mix(in oklab, var(--primary-color) 18%, transparent);
		outline-offset: 2px;
	}
}
</style>

<ul>
	{
		headings.map((heading: any) => (
			<li id={`indicator-${heading.slug}`}>
				<a href={`#${heading.slug}`}>{heading.text}</a>
				{heading.subheadings?.length > 0 && <Self headings={heading.subheadings} />}
			</li>
		))
	}
</ul>

<script>
	// Global variable to store the IntersectionObserver instance
	// Used to clean up previous observer when re-initializing
	let observer: IntersectionObserver | undefined;

	/**
	 * Initialize Table of Contents functionality with scroll-based highlighting
	 * Sets up intersection observer to highlight current section in TOC
	 */
	function TOC() {
		// Create a Map for efficient lookup of TOC indicators by heading slug
		// Maps heading slug to corresponding TOC list item element
		const indicators = new Map<string, Element>(
			document
				.querySelectorAll("li[id^='indicator-']") // Select all TOC indicator elements
				.values()
				.map(indicator => [
					indicator.id.replace(/^indicator-/, ""), // Extract slug from "indicator-{slug}" format
					indicator // Store the indicator element
				])
		);

		// Disconnect previous observer to prevent memory leaks
		observer?.disconnect();

		// Create new IntersectionObserver to detect when headings enter/leave viewport
		observer = new IntersectionObserver(entries =>
			entries.forEach(
				({ target, isIntersecting }) =>
					// Toggle "indicate" class on corresponding TOC item based on visibility
					indicators
						.get(target.getAttribute("aria-labelledby")!) // Get heading slug from aria-labelledby
						?.classList.toggle("indicate", isIntersecting) // Add/remove highlight class
			)
		);

		// Find all heading sections in the markdown content and observe them
		document
			.querySelector("#markdown-content") // Get main content container
			?.querySelectorAll("section[data-heading-rank]") // Find all heading sections
			.forEach(section => observer?.observe(section)); // Start observing each section
	}

	// Initialize TOC functionality when page loads
	TOC();

	// Re-initialize TOC after Astro's view transitions complete
	// This ensures TOC works correctly with client-side navigation
	document.addEventListener("astro:after-swap", TOC);
</script>

---
title: "Параллель B<br>Алгоритмы поиска кратчайшего пути: полный набор инструментов"
timestamp: 2025-10-25T16:20:00+03:00
last_updated_timestamp: 2025-11-08T10:05:00+03:00
series: "T-Образование"
tags:
  - Tbank
  - Tgeneration
  - ShortestPaths
  - GraphAlgorithms
  - Dijkstra
  - BellmanFord
  - FloydWarshall
description: >-
  От BFS с несколькими источниками до 0-1 BFS, Дейкстры, Беллмана-Форда, Флойда-Уоршелла.
  Как выбрать нужный алгоритм? Как обнаружить отрицательные циклы? Практические трюки для контестов.
---

<h2>Тема конспекта: Кратчайший путь — выбери свой алгоритм</h2>

> **Главный автор:** Вадим Христенко  
> **Другие авторы:** —  
> **Последнее обновление:** 2025-11-08  
> **Ссылка на обсуждение:** https://github.com/Vadim-Khristenko/Tedu_Notes/discussions/2
> _Комментарий:_ Всё, что нужно знать о поиске кратчайших путей. От простых до извращённых граничных случаев.  
> _Теги:_ ShortestPath, Dijkstra, BellmanFord, FloydWarshall, NegativeCycles, BFS, GraphTheory

---

# Введение {id: "introduction"}

**Кратчайший путь** — одна из базовых задач в графах. Но есть множество вариаций:
- Граф с положительными весами? → Дейкстра
- С отрицательными, но без циклов? → Беллман-Форд
- Все пары? → Флойд-Уоршелл
- Только рёбра весом 0 и 1? → 0-1 BFS

**Цель конспекта:** понять, когда использовать что, и как избежать подводных камней.

---

# Содержание {id: "contents"}

1. [Базовые понятия графов](#graph-basics)
2. [Выбор структуры данных для графа](#graph-representation)
3. [BFS классический и с несколькими источниками](#bfs)
4. [0-1 BFS](#zero-one-bfs)
5. [Dial / 0-K BFS](#zero-k-bfs)
6. [Алгоритм Дейкстры](#dijkstra)
7. [Кратчайшие пути в DAG](#dag-shortest)
8. [Беллман-Форд и SPFA](#bellman-ford)
9. [Флойд-Уоршелл](#floyd-warshall)
10. [Johnson: все пары на разреженных графах](#johnson)
11. [Восстановление пути (parent-массивы)](#path-reconstruction)
12. [Обнаружение отрицательных циклов](#negative-cycles)
13. [Дерево решений и типичные ошибки](#decision-tree)
14. [Практические примеры](#examples)
15. [Таблица выбора алгоритма](#algorithm-choice)

---

# Базовые понятия графов {id: "graph-basics"}

Чтобы уверенно выбирать алгоритм, нужно точно понимать исходную модель.

Термины:
- Вершины (nodes / vertices) и рёбра (edges / arcs). Рёбра бывают ориентированные и неориентированные.
- Вес ребра (weight / cost / length) — число, добавляющееся к суммарной длине пути.
- Путь — последовательность вершин, где каждая пара соседних соединена ребром.
- Цикл — путь, начинающийся и заканчивающийся в одной вершине. Отрицательный цикл — суммарный вес < 0.
- Расстояние (distance) от s до v — минимальная суммарная длина среди всех путей из s в v, или ∞ (недостижимо).

Типовые диапазоны весов в задачах:
- Все веса = 1 (или равные) → BFS.
- Веса из {0,1} → 0-1 BFS.
- Небольшие целые 0..C → Dial (bucket) / "0-K BFS".
- Неотрицательные произвольные → Дейкстра / многократная Дейкстра.
- Есть отрицательные → Беллман-Форд / Johnson (если нужно все пары) / Флойд-Уоршелл при малом V.
- Есть подозрение на отрицательные циклы → обязательно проверка Bellman-Ford или FW.

Что считать INF:
- Для int: обычно 1e9 или 2e9 (чтобы не переполнить при сложении).
- Для long long: 4e18 (пример: const long long INF = 4e18;).
Никогда не складывайте INF с чем-то без проверки (dist[u] != INF), иначе переполнение.

Сложность и плотность:
- Разреженный граф: E ≈ V .. V log V.
- Плотный: E ≈ V^2.
Выбор структуры и алгоритма зависит от отношения E к V.

---

# Выбор структуры данных для графа {id: "graph-representation"}

Основные варианты хранения:

1. Списки смежности (vector<vector<pair<int,int>>>):
    - Плюсы: эффективно по памяти для разреженных графов, удобно итерировать исходящие рёбра.
    - Минусы: поиск существования ребра O(outdeg(u)).

2. Матрица смежности (vector<vector<int>>):
    - Плюсы: моментальный доступ к весу между i и j (O(1)).
    - Минусы: память O(V^2). Используйте при V ≤ ~2000 или для Флойда.

3. Список рёбер (vector<tuple<u,v,w>>):
    - Плюсы: удобно для Беллмана-Форда (линейный проход по рёбрам).
    - Минусы: нет быстрых исходящих списков → не подходит для Дейкстры напрямую.

4. Сжатые структуры (CSR — compressed sparse row):
    - Быстрее при большом числе алгоритмов подряд (например, много итераций Джонсона).

Рекомендация: храните и списки смежности, и массив рёбер если нужны оба подхода.

---

# BFS классический и с несколькими источниками {id: "bfs"}

## Классический BFS

Ищет кратчайший путь в **неориентированном** или **ориентированном графе с рёбрами одинакового веса** (обычно 1).

Алгоритм работает в два этапа: добавляем стартовую вершину в очередь, затем для каждой вершины из очереди исследуем всех соседей, и если сосед ещё не посещён, заносим его расстояние и добавляем в очередь. Гарантия корректности основана на том, что очередь обрабатывает вершины в порядке возрастания расстояния.

```cpp
vector<int> bfs(vector<vector<int>>& adj, int start, int n) {
    vector<int> dist(n, -1);
    queue<int> q;
    q.push(start);
    dist[start] = 0;
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        
        for (int v : adj[u]) {
            if (dist[v] == -1) {
                dist[v] = dist[u] + 1;
                q.push(v);
            }
        }
    }
    
    return dist;
}
```

**Сложность:** $O(V + E)$

---

## BFS с несколькими источниками

Часто требуется найти расстояния от **множества вершин** до остального графа. Типичный пример: в сетке есть несколько огней, нужно найти расстояние от каждой клетки до ближайшего огня.

**Трюк:** вместо добавления фиктивной вершины просто инициализируем все исходные вершины расстоянием 0 и поместим их в очередь перед началом основного цикла. Дальше BFS работает как обычно — будут обнаружены расстояния до всех остальных вершин, измеренные от ближайшего из источников.

```cpp
vector<int> multi_source_bfs(vector<vector<int>>& adj, vector<int> sources, int n) {
    vector<int> dist(n, INT_MAX);
    queue<int> q;
    
    // Инициализируем все источники
    for (int src : sources) {
        dist[src] = 0;
        q.push(src);
    }
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        
        for (int v : adj[u]) {
            if (dist[v] > dist[u] + 1) {
                dist[v] = dist[u] + 1;
                q.push(v);
            }
        }
    }
    
    return dist;
}
```

**Когда это работает:** если все рёбра имеют одинаковый вес.

---

# 0-1 BFS {id: "zero-one-bfs"}

Для графа, где **каждое ребро весит либо 0, либо 1**.

**Ключевая идея:** используем `deque` (двусторонняя очередь):
- Рёбра веса 0 добавляем в **начало**
- Рёбра веса 1 добавляем в **конец**

Это гарантирует, что очередь остаётся отсортирована по расстоянию.

```cpp
vector<int> zero_one_bfs(int n, vector<pair<int, int>>& edges, int start) {
    // edges[i] = {u, v} с неявным весом (определяется по типу ребра)
    vector<vector<pair<int, int>>> adj(n); // {vertex, weight}
    
    for (auto [u, v] : edges) {
        adj[u].push_back({v, 0}); // или {v, 1} в зависимости от задачи
    }
    
    vector<int> dist(n, INT_MAX);
    deque<int> dq;
    dq.push_back(start);
    dist[start] = 0;
    
    while (!dq.empty()) {
        int u = dq.front();
        dq.pop_front();
        
        for (auto [v, w] : adj[u]) {
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                if (w == 0) {
                    dq.push_front(v);
                } else {
                    dq.push_back(v);
                }
            }
        }
    }
    
    return dist;
}
```

**Сложность:** $O(V + E)$ — каждая вершина посещается один раз!

**Пример:** рёбра между соседними ячейками сетки весят 0 (если горизонтальные/вертикальные) и 1 (если диагональные).

---

# 0-K BFS {id: "zero-k-bfs"}

Обобщение: рёбра весят от 0 до $K$ (или значения из небольшого диапазона). Этот подход чаще называют **Dial's algorithm** (алгоритм Дайала) для неотрицательных целых весов в интервале [0, C]. Сохраним старый якорь, чтобы не ломать ссылки.

Идея: используем массив очередей (bucket'ов) size = K+1. Индекс соответствует текущему расстоянию по модулю (K+1). Это напоминает "круговую" версию приоритетной очереди, где операция Decrease-Key реализуется помещением вершины в правильный bucket.

Условия эффективности:
- Вес ребра w ∈ [0, K].
- Максимальная дистанция не слишком велика, иначе цикл модулей потеряет эффективность.

Сложность: O(V + E * (K / avgBucketFill)) приблизительно, в классической оценке часто указывают O(VK + E) для неблагоприятного распределения. На практике при малом K (≤ 1000) и умеренных расстояниях работает быстрее Дейкстры с бинарной кучей.

Подводные камни:
- Если встречаются веса > K — алгоритм некорректен.
- При очень больших конечных расстояниях число пустых проверок bucket'ов растёт.
- Не подходит для отрицательных весов.

```cpp
vector<long long> zero_k_bfs(int n, vector<tuple<int, int, int>>& edges, int k, int start) {
    vector<vector<pair<int, int>>> adj(n); // {vertex, weight}
    
    for (auto [u, v, w] : edges) {
        adj[u].push_back({v, w});
        adj[v].push_back({u, w});
    }
    
    vector<long long> dist(n, LLONG_MAX);
    vector<deque<int>> buckets(k + 1);
    buckets[0].push_back(start);
    dist[start] = 0;
    
    int current_dist = 0;
    
    while (true) {
        bool found = false;
        for (int bucket = current_dist; bucket <= current_dist + k; bucket++) {
            if (!buckets[bucket % (k + 1)].empty()) {
                found = true;
                break;
            }
        }
        if (!found) break;
        
        int u = buckets[current_dist % (k + 1)].front();
        buckets[current_dist % (k + 1)].pop_front();
        
        if (dist[u] < current_dist) continue; // уже обработан
        
        for (auto [v, w] : adj[u]) {
            long long new_dist = dist[u] + w;
            if (new_dist < dist[v]) {
                dist[v] = new_dist;
                buckets[new_dist % (k + 1)].push_back(v);
            }
        }
        
        current_dist++;
    }
    
    return dist;
}
```

**Когда использовать:** граф с небольшими весами (до $10^3$), когда Дейкстра медленнее.

**Альтернатива:** Если веса распределены неравномерно, попробуйте радикс-подобные оптимизации (multi-level buckets) или Pairing Heap/фибоначчиева куча (но в контестах редко оправдано).

---

## Алгоритм Дейкстры {id: "dijkstra"}

**Условие:** граф с **неотрицательными весами**.

Интуиция: алгоритм жадный, на каждом шаге мы выбираем непосещённую вершину с минимальным расстоянием и «закрываем» её. После выбора очередной вершины мы гарантировано нашли до неё кратчайший путь, потому что все рёбра имеют неотрицательные веса, а любой альтернативный путь через оставшиеся вершины может только быть длиннее.


```mermaid
graph LR
    A["Выбираем непосещённую<br/>вершину с мин. dist"]
    B["Расслабляем рёбра"]
    C["Все вершины<br/>посещены?"]
    A --> B
    B --> C
    C -->|Нет| A
    C -->|Да| D["Готово"]
    
    classDef process fill:#0066cc,stroke:#003366,color:#fff
    class A,B process
```

## Реализация с приоритетной очередью O((V+E) log V)

```cpp
vector<long long> dijkstra(vector<vector<pair<int, long long>>>& adj, int start, int n) {
    vector<long long> dist(n, LLONG_MAX);
    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;
    
    dist[start] = 0;
    pq.push({0, start});
    
    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();
        
        if (d > dist[u]) continue; // уже обработан с меньшей дистанцией
        
        for (auto [v, w] : adj[u]) {
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }
    
    return dist;
}
```

## Реализация O(V²) без приоритетной очереди

```cpp
vector<long long> dijkstra_v2(vector<vector<pair<int, long long>>>& adj, int start, int n) {
    vector<long long> dist(n, LLONG_MAX);
    vector<bool> used(n, false);
    dist[start] = 0;
    
    for (int i = 0; i < n; i++) {
        int u = -1;
        for (int j = 0; j < n; j++) {
            if (!used[j] && (u == -1 || dist[j] < dist[u])) {
                u = j;
            }
        }
        
        if (u == -1 || dist[u] == LLONG_MAX) break;
        used[u] = true;
        
        for (auto [v, w] : adj[u]) {
            if (dist[v] > dist[u] + w) dist[v] = dist[u] + w;
        }
    }
    
    return dist;
}
```

### Инвариант Дейкстры

После извлечения вершины u из min-кучи её расстояние dist[u] окончательно минимально. Это верно, потому что все пути к другим вершинам либо имеют вес ≥ dist[u], либо ещё не могут быть улучшены без использования уже "закрытых" вершин с неотрицательными весами. **Критически важно:** этот инвариант полностью зависит от неотрицательности весов; если в графе есть отрицательные рёбра, алгоритм дает неверный результат и требуется Беллман-Форд.


### Практические трюки
- Multi-source: положите несколько стартовых вершин в очередь с расстоянием 0.
- Раннее завершение: если ищете расстояние только до одной целевой t — можно остановиться, когда t извлечена.
- Decrease-Key vs Push-Duplicate: большинство реализаций просто пушат новую пару (dist, v) и игнорируют устаревшую при извлечении (проверка if (d > dist[v])). Это быстрее в коде и достаточно эффективно.
- Тип веса: используйте long long. Даже если вход ≤ 1e9, сумма может превысить 32-бит.
- Предотвращение TLE: резервируйте память adj[v].reserve(outdeg); и избегайте тяжёлых структур (map, set) внутри цикла.

### Структуры куч
- binary heap (priority_queue) — стандарт.
- pairing heap / Fibonacci — Теоретически O(E + V log V) → улучшает Decrease-Key, но оверхед чаще медленнее на практике.

### Edge cases
- Недостижимые вершины: dist[v] остаётся INF.
- Слишком большие веса: возможное переполнение при dist[u] + w → проверяйте dist[u] > INF/2.

---

## Кратчайшие пути в DAG {id: "dag-shortest"}

Если граф — **ориентированный ацикличный** (DAG), задача упрощается: можно получить все кратчайшие пути от источника за O(V + E) через топологический порядок. Это значительно быстрее, чем Дейкстра или Беллман-Форд, и работает даже с отрицательными весами (если нет циклов).

**Механизм:** вершины в топологическом порядке гарантированно обрабатываются «слева направо» в смысле зависимостей, поэтому когда мы релаксируем рёбра из вершины u, все её предки уже имеют финальные расстояния.


Шаги:
1. Найдите топологический порядок вершин (DFS или Kahn).
2. Инициализируйте dist[source] = 0, остальные INF.
3. Итерируйте вершины в порядке: релаксируйте исходящие рёбра.

```cpp
vector<long long> dag_shortest(int n, vector<vector<pair<int,long long>>>& adj, int start) {
    vector<int> indeg(n,0);
    for(int u=0;u<n;++u) for(auto [v,w]:adj[u]) indeg[v]++;
    queue<int> q; for(int i=0;i<n;++i) if(indeg[i]==0) q.push(i);
    vector<int> topo; topo.reserve(n);
    while(!q.empty()){int u=q.front();q.pop();topo.push_back(u);for(auto [v,w]:adj[u]) if(--indeg[v]==0) q.push(v);}    
    vector<long long> dist(n, 4e18); dist[start]=0;
    for(int u: topo){ if(dist[u]==4e18) continue; for(auto [v,w]:adj[u]) if(dist[v] > dist[u] + w) dist[v]=dist[u]+w; }
    return dist;
}
```

Преимущества:
- Работает с отрицательными весами (если нет циклов, в том числе отрицательных очевидно).
- Быстрее Дейкстры/Беллмана.

Определение DAG в контесте: часто встречается в зависимостях задач, очередности курсов, планировании.

---

## Беллман-Форд {id: "bellman-ford"}

Работает с **отрицательными весами**, может обнаружить **отрицательные циклы**. Основная идея заключается в том, что кратчайший простой путь содержит не более V-1 рёбер (так как в графе V вершин). Поэтому если после V-1 итераций релаксации произойдёт ещё одно улучшение, это означает существование отрицательного цикла, достижимого из источника.

**Условия работы:** на каждой итерации проходим по всем рёбрам и для каждого ребра (u, v, w) проверяем, может ли путь через u быть улучшен.


```cpp
vector<long long> bellman_ford(int n, vector<tuple<int, int, long long>>& edges, int start) {
    vector<long long> dist(n, LLONG_MAX);
    dist[start] = 0;
    
    // Релаксируем V-1 раз
    for (int i = 0; i < n - 1; i++) {
        for (auto [u, v, w] : edges) {
            if (dist[u] != LLONG_MAX && dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
            }
        }
    }
    
    // Проверка отрицательного цикла
    vector<bool> in_cycle(n, false);
    for (auto [u, v, w] : edges) {
        if (dist[u] != LLONG_MAX && dist[u] + w < dist[v]) {
            in_cycle[v] = true;
        }
    }
    
    // Распространяем отрицательный цикл
    for (int i = 0; i < n; i++) {
        for (auto [u, v, w] : edges) {
            if (in_cycle[u]) in_cycle[v] = true;
        }
    }
    
    // Отмечаем расстояния до вершин в отрицательном цикле как -INF
    for (int i = 0; i < n; i++) {
        if (in_cycle[i]) dist[i] = LLONG_MIN / 2;
    }
    
    return dist;
}
```

**Сложность:** $O(VE)$

---

## Беллман-Форд на очереди (SPFA)

Оптимизация Беллмана-Форда: обновляем только если узел был релаксирован на последней итерации. Вместо перебора всех рёбер на каждой итерации, сохраняем в очереди только вершины, которые недавно были улучшены. Это позволяет избежать лишних проверок на разреженных графах.

**Название:** Shortest Path Faster Algorithm (SPFA) — предложена китайским программистом Фань Лицзюем.



### Интуиция корректности
Любой кратчайший путь содержит не более V-1 рёбер (без цикла). Поэтому после V-1 полных релаксаций все истинные расстояния установлены. Если на V-й итерации что-то улучшилось — в путь добавился цикл ⇒ он отрицателен.

### Негативные циклы и распространение
Базовое обнаружение отмечает вершины, которые можно ещё улучшить; чтобы пометить все вершины достижимые из отрицательного цикла, запускаем распространение (как в коде выше) — это полезно, если нужно отличать "-∞" расстояния.

### SPFA — когда применять
- Очень разреженный граф.
- Большинство рёбер не приводит к обновлению.
Но: существуют контр-примеры (специально сконструированные), где SPFA работает так же долго как Bellman-Ford.

### Хитрости оптимизации SPFA
- Small Label First (SLF): если dist[v] < dist[q.front()], помещаем v в начало очереди.
- Large Label Last (LLL): периодически реорганизуем очередь, отправляя вершины с большими метками назад.
В контестах чаще достаточно базовой версии + счётчика обновлений.

---
```cpp
vector<long long> spfa(vector<vector<pair<int, long long>>>& adj, int start, int n) {
    vector<long long> dist(n, LLONG_MAX);
    vector<int> cnt(n, 0); // счётчик обновлений
    vector<bool> in_queue(n, false);
    queue<int> q;
    
    dist[start] = 0;
    q.push(start);
    in_queue[start] = true;
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        in_queue[u] = false;
        
        for (auto [v, w] : adj[u]) {
            if (dist[u] != LLONG_MAX && dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                cnt[v]++;
                
                if (cnt[v] > n) {
                    // Отрицательный цикл
                    return vector<long long>(n, LLONG_MIN);
                }
                
                if (!in_queue[v]) {
                    q.push(v);
                    in_queue[v] = true;
                }
            }
        }
    }
    
    return dist;
}
```

**Сложность:** $O(VE)$ в худшем, $O(E)$ в среднем.

---

## Флойд-Уоршелл {id: "floyd-warshall"}

Для **всех пар вершин одновременно**. Работает с отрицательными весами (но не циклами). Динамическое программирование: состояние `dist[i][j][k]` = кратчайший путь от i к j, использующий только вершины 0..k как промежуточные. Тройной цикл по k (промежуточная вершина), i (начало), j (конец) вычисляет все пары.

**Преимущество:** простая реализация, хорошо для малых графов.
**Недостаток:** кубическая сложность неприменима для больших V.


```cpp
void floyd_warshall(vector<vector<long long>>& dist, int n) {
    // dist[i][j] = кратчайшее расстояние от i к j
    // Инициализируем: dist[i][i] = 0, остальные = INF или веса рёбер
    
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][k] != LLONG_MAX && dist[k][j] != LLONG_MAX) {
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                }
            }
        }
    }
}
```

**Сложность:** $O(V^3)$ — не масштабируется для больших графов!

**Когда использовать:** $V \leq 500$.

### Path reconstruction
Дополнительно храните предшественника:
```cpp
void floyd_with_parent(vector<vector<long long>>& dist, vector<vector<int>>& parent, int n){
    for(int k=0;k<n;k++){
        for(int i=0;i<n;i++) if(dist[i][k]!=LLONG_MAX)
            for(int j=0;j<n;j++) if(dist[k][j]!=LLONG_MAX && dist[i][k]+dist[k][j] < dist[i][j]){
                dist[i][j]=dist[i][k]+dist[k][j];
                parent[i][j]=parent[k][j];
            }
    }
}
```
Реконструкция пути i→j: идём j = parent[i][j] пока не достигнем i (собирая вектор в обратном порядке).

### Обнаружение отрицательных циклов расширенно
После работы: если dist[i][i] < 0, эта вершина лежит в отрицательном цикле. Можно дополнительно пройти по всем j и через i улучшать, отмечая вовлечённые.

---

## Johnson: все пары на разреженных графах {id: "johnson"}

Сценарий: нужно расстояние между **всеми парами**, веса могут быть отрицательными, но **нет отрицательных циклов**, и граф **разреженный** (E ≪ V²). Флойд-Уоршелл слишком медленный O(V³), но запустить V раз Дейкстру можно; проблема только в отрицательных весах.

**Решение:** переверзить граф так, чтобы все веса стали неотрицательными, потом запустить V раз Дейкстру, потом восстановить истинные расстояния.


Шаги:
1. Добавить фиктивную вершину s и рёбра (s → v) весом 0 ко всем v.
2. Запустить Беллман-Форд от s, получить потенциалы h[v] = dist_s[v]. Если обнаружен отрицательный цикл — стоп.
3. Перевзвесить каждое ребро (u→v) весом w' = w + h[u] - h[v] (все w' ≥ 0).
4. Для каждого u запустить Дейкстру на перевзвешенном графе, получая d'[u][v]. Истинное расстояние: d[u][v] = d'[u][v] - h[u] + h[v].

Сложность: O(VE + V * (E log V)). Для разреженных графов лучше чем O(V^3).

Плюсы: работает с отрицательными ребрами (без отрицательных циклов).
Минусы: дополнительная память под потенциалы; требует аккуратных типов (long long).

---

## Восстановление пути (parent-массивы) {id: "path-reconstruction"}

Часто нужно не только длина, но и сам путь.

## BFS / multi-source BFS
```cpp
vector<int> parent(n, -1);
queue<int> q; dist[start]=0; q.push(start);
while(!q.empty()){int u=q.front();q.pop();for(int v:adj[u]) if(dist[v]==-1){dist[v]=dist[u]+1; parent[v]=u; q.push(v);} }
// восстановление: vector<int> path; for(int v=target; v!=-1; v=parent[v]) path.push_back(v); reverse(path.begin(),path.end());
```

## Дейкстра
При релаксации: if (dist[u] + w < dist[v]) { dist[v] = dist[u] + w; parent[v] = u; }

## Беллман-Форд
Аналогично; но если отрицательные циклы: вершины достижимые из цикла не имеют корректного пути — помечайте parent[v] = -2 или отдельный массив.

## Проверка корректности пути
После реконструкции суммируйте веса рёбер и сравните с dist[target]. Если различаются — ошибка в parent.

---

## Обнаружение отрицательных циклов {id: "negative-cycles"}

Рассмотрим три метода, каждый с разными компромиссами.

### Метод 1: Беллман-Форд + проверка


После $V-1$ итераций пытаемся ещё раз. Если что-то изменилось — цикл.

## Метод 2: Флойд-Уоршелл

После алгоритма проверяем диагональ: если $dist[i][i] < 0$ — цикл.

```cpp
bool has_negative_cycle_fw(vector<vector<long long>>& dist, int n) {
    floyd_warshall(dist, n);
    for (int i = 0; i < n; i++) {
        if (dist[i][i] < 0) return true;
    }
    return false;
}
```

## Метод 3: DFS + состояния окраски

Используем три состояния: белый (непосещённый), серый (в стеке), чёрный (завершён).
Если встретили серую вершину — цикл.

```cpp
bool has_negative_cycle_dfs(vector<vector<pair<int, long long>>>& adj, int n) {
    enum Color { WHITE = 0, GRAY = 1, BLACK = 2 };
    vector<int> color(n, WHITE);
    
    function<bool(int)> dfs = [&](int u) {
        color[u] = GRAY;
        for (auto [v, w] : adj[u]) {
            if (color[v] == GRAY) {
                return true; // цикл
            }
            if (color[v] == WHITE && dfs(v)) {
                return true;
            }
        }
        color[u] = BLACK;
        return false;
    };
    
    for (int i = 0; i < n; i++) {
        if (color[i] == WHITE && dfs(i)) {
            return true;
        }
    }
    return false;
}
```

### Важное замечание

DFS по окраске сам по себе не выявляет именно **отрицательный** цикл — только наличие цикла. Чтобы удостовериться, что цикл отрицательный, нужно учитывать веса. Комбинация: топологическая проверка (если есть цикл) + попытка улучшить расстояния (Bellman-Ford). Приведённая функция полезна как первичная фильтрация для DAG.

---

## Дерево решений и типичные ошибки {id: "decision-tree"}

**Дерево выбора:**

1. Нужно все пары? → Да:
     - V ≤ 500 → Флойд-Уоршелл.
     - Иначе: Есть отрицательные веса? → Да → Johnson; Нет → V раз Дейкстра (или сохранение SSSP для нужных источников).
2. Только один источник? → Да:
     - Есть отрицательные ребра? → Да:
         - Есть цикл? (подозрение) → Беллман-Форд для проверки.
         - Нет (DAG) → DAG shortest (топологический порядок).
         - Иначе → Беллман-Форд / SPFA.
     - Нет отрицательных:
         - Все веса = 1 → BFS.
         - Вес ∈ {0,1} → 0-1 BFS.
         - Малый диапазон 0..K (K ≤ 1000) → Dial.
         - Иначе → Дейкстра.

Типичные ошибки:

- Забывают обнулить dist/start или parent перед новым запуском.
- Переполнение int при сложении весов.
- Использование BFS для взвешенного графа (получается неверно).
- Неправильная инициализация матрицы для Флойда (не выставили `dist[i][i] = 0`).
- Преследование оптимизации: применение SPFA на графе где он деградирует (например, длинная цепочка + обратные рёбра) → TLE.
- Не проверяют недостижимость и печатают мусор (например, большую константу вместо "-1" или "INF").
- Случайные отрицательные циклы при вводе (не предусмотрели проверку) → бесконечные обновления.

Советы:
- Всегда определяйте "контракт" функции: вход, выход, значение для недостижимой вершины.
- Выносите INF и типы в константы.
- Тестируйте на микро-примерах: 1 вершина, 2 вершины, треугольник, граф с изолированной вершиной.

---

## Практические примеры {id: "examples"}

### Пример 1: Лабиринт с пошлиной

Граф — сетка. Горизонтальные/вертикальные переходы = 0, диагональные = 1.

**Решение:** 0-1 BFS.

```cpp
// Используем zero_one_bfs с рёбрами веса 0 и 1
```

### Пример 2: Обнаружение арбитража (отрицательного цикла)

Валюты и курсы обмена. Если существует последовательность обменов, дающая прибыль — это отрицательный цикл в логарифмическом масштабе.

**Решение:** SPFA для обнаружения.

```cpp
// Логарифмируем: dist[v] = min(dist[v], dist[u] + log(weight))
// Ищем отрицательные циклы в SPFA
```

### Пример 3: Кратчайшие расстояния между всеми аэропортами

$V \approx 50000$, нужны расстояния от одного аэропорта к 5 другим.

**Решение:** 5× Дейкстра, не Флойд-Уоршелл!

### Пример 4: Сборка пакетов (DAG)

Имеются зависимости между задачами/пакетами. Нужно минимальное "время" (вес ребра = задержка) до каждой. Если граф — DAG → топологический порядок + релаксация.

### Пример 5: Оптимальные курсы валют

Курсы обмена (u→v) = rate. Преобразуем веса: w = -log(rate). Задача поиска отрицательного цикла превращается в поиск цикла с суммой < 0 (арбитраж). Используем Беллман-Форд.

### Пример 6: Минимальная стоимость перемещения робота

Сетка N×M, перемещение по ровной клетке = 1, на бустер = 0. Рёбра {0,1}. Используем 0-1 BFS; Дейкстра будет дороже по константам.

### Пример 7: Сеть дорог с платными участками

Весы в диапазоне 0..50. Попытка Дейкстры (log V) против Dial (K=50). Dial может быть быстрее, особенно при большом V.

### Пример 8: Все пары в разреженной социальной сети (V=20k, E=80k)

Нужны расстояния не между всеми парами, а между ядром избранных узлов. Запускаем Дейкстру из каждого узла ядра; экономим по сравнению с FW.

---

## Таблица выбора алгоритма {id: "algorithm-choice"}

| Задача | Граф | Алгоритм | Сложность |
|--------|------|----------|-----------|
| Кратчайший путь от одного | Неотрицательные веса | Dijkstra | $(V+E) \log V$ |
| Кратчайший путь от одного | Отрицательные, без циклов | Беллман-Форд или SPFA | $VE$ или $E$ |
| Все пары | $V \leq 500$ | Флойд-Уоршелл | $V^3$ |
| Все пары | $V$ велико | V раз Дейкстра | $V(V+E)\log V$ |
| 0-1 рёбра | Двоичные веса | 0-1 BFS | $V+E$ |
| Обнаружить отрицательный цикл | Любые | Беллман-Форд или SPFA | $VE$ |
| Все пары, отрицательные веса, разреженный | Нет отриц. циклов | Johnson | $VE + V(E\log V)$ |
| Кратчайший путь от одного | DAG | Топологический порядок | $V+E$ |
| Кратчайший путь от одного | Малые веса 0..K | Dial (bucket) | $V+E + VK_{local}$ |

---

$\text{От ученика для учеников.}\\ \text{\textcolor{red}{С любовью} к \textcolor{yellow}{Т-Образованию}.}\\ \textcolor{cyan}{Вадим\ Христенко.}$

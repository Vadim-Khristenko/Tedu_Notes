---
title: "Параллель B<br>Алгоритмы поиска кратчайшего пути: полный набор инструментов"
timestamp: 2025-10-25T16:20:00+03:00
last_updated_timestamp: 2025-11-01T19:15:00+03:00
series: "T-Образование"
tags:
  - Tbank
  - Tgeneration
  - ShortestPaths
  - GraphAlgorithms
  - Dijkstra
  - BellmanFord
  - FloydWarshall
description: >-
  От BFS с несколькими источниками до 0-1 BFS, Дейкстры, Беллмана-Форда, Флойда-Уоршелла.
  Как выбрать нужный алгоритм? Как обнаружить отрицательные циклы? Практические трюки для контестов.
---

<h2>Тема конспекта: Кратчайший путь — выбери свой алгоритм</h2>

> **Главный автор:** Вадим Христенко  
> **Другие авторы:** —  
> **Последнее обновление:** 2025-11-01  
> **Ссылка на обсуждение:** https://github.com/Vadim-Khristenko/Tedu_Notes/discussions/2
> _Комментарий:_ Всё, что нужно знать о поиске кратчайших путей. От простых до извращённых граничных случаев.  
> _Теги:_ ShortestPath, Dijkstra, BellmanFord, FloydWarshall, NegativeCycles, BFS, GraphTheory

---

# Введение {id: "introduction"}

**Кратчайший путь** — одна из базовых задач в графах. Но есть множество вариаций:
- Граф с положительными весами? → Дейкстра
- С отрицательными, но без циклов? → Беллман-Форд
- Все пары? → Флойд-Уоршелл
- Только рёбра весом 0 и 1? → 0-1 BFS

**Цель конспекта:** понять, когда использовать что, и как избежать подводных камней.

---

# Содержание {id: "contents"}

1. [BFS классический и с несколькими источниками](#bfs)
2. [0-1 BFS](#zero-one-bfs)
3. [0-K BFS](#zero-k-bfs)
4. [Алгоритм Дейкстры](#dijkstra)
5. [Беллман-Форд](#bellman-ford)
6. [Флойд-Уоршелл](#floyd-warshall)
7. [Обнаружение отрицательных циклов](#negative-cycles)
8. [Практические примеры](#examples)

---

# BFS классический и с несколькими источниками {id: "bfs"}

## Классический BFS

Ищет кратчайший путь в **неориентированном** или **ориентированном графе с рёбрами одинакового веса** (обычно 1).

```cpp
vector<int> bfs(vector<vector<int>>& adj, int start, int n) {
    vector<int> dist(n, -1);
    queue<int> q;
    q.push(start);
    dist[start] = 0;
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        
        for (int v : adj[u]) {
            if (dist[v] == -1) {
                dist[v] = dist[u] + 1;
                q.push(v);
            }
        }
    }
    
    return dist;
}
```

**Сложность:** $O(V + E)$

---

## BFS с несколькими источниками

Часто требуется найти расстояния от **множества вершин** до остального графа. Трюк: добавляем фиктивный источник, соединённый со всеми нулевым весом.

```cpp
vector<int> multi_source_bfs(vector<vector<int>>& adj, vector<int> sources, int n) {
    vector<int> dist(n, INT_MAX);
    queue<int> q;
    
    // Инициализируем все источники
    for (int src : sources) {
        dist[src] = 0;
        q.push(src);
    }
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        
        for (int v : adj[u]) {
            if (dist[v] > dist[u] + 1) {
                dist[v] = dist[u] + 1;
                q.push(v);
            }
        }
    }
    
    return dist;
}
```

**Когда это работает:** если все рёбра имеют одинаковый вес.

---

# 0-1 BFS {id: "zero-one-bfs"}

Для графа, где **каждое ребро весит либо 0, либо 1**.

**Ключевая идея:** используем `deque` (двусторонняя очередь):
- Рёбра веса 0 добавляем в **начало**
- Рёбра веса 1 добавляем в **конец**

Это гарантирует, что очередь остаётся отсортирована по расстоянию.

```cpp
vector<int> zero_one_bfs(int n, vector<pair<int, int>>& edges, int start) {
    // edges[i] = {u, v} с неявным весом (определяется по типу ребра)
    vector<vector<pair<int, int>>> adj(n); // {vertex, weight}
    
    for (auto [u, v] : edges) {
        adj[u].push_back({v, 0}); // или {v, 1} в зависимости от задачи
    }
    
    vector<int> dist(n, INT_MAX);
    deque<int> dq;
    dq.push_back(start);
    dist[start] = 0;
    
    while (!dq.empty()) {
        int u = dq.front();
        dq.pop_front();
        
        for (auto [v, w] : adj[u]) {
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                if (w == 0) {
                    dq.push_front(v);
                } else {
                    dq.push_back(v);
                }
            }
        }
    }
    
    return dist;
}
```

**Сложность:** $O(V + E)$ — каждая вершина посещается один раз!

**Пример:** рёбра между соседними ячейками сетки весят 0 (если горизонтальные/вертикальные) и 1 (если диагональные).

---

# 0-K BFS {id: "zero-k-bfs"}

Обобщение: рёбра весят от 0 до $K$ (или значения из конечного набора).

Используем **K+1 очередей** (циклический буфер).

```cpp
vector<long long> zero_k_bfs(int n, vector<tuple<int, int, int>>& edges, int k, int start) {
    vector<vector<pair<int, int>>> adj(n); // {vertex, weight}
    
    for (auto [u, v, w] : edges) {
        adj[u].push_back({v, w});
        adj[v].push_back({u, w});
    }
    
    vector<long long> dist(n, LLONG_MAX);
    vector<deque<int>> buckets(k + 1);
    buckets[0].push_back(start);
    dist[start] = 0;
    
    int current_dist = 0;
    
    while (true) {
        bool found = false;
        for (int bucket = current_dist; bucket <= current_dist + k; bucket++) {
            if (!buckets[bucket % (k + 1)].empty()) {
                found = true;
                break;
            }
        }
        if (!found) break;
        
        int u = buckets[current_dist % (k + 1)].front();
        buckets[current_dist % (k + 1)].pop_front();
        
        if (dist[u] < current_dist) continue; // уже обработан
        
        for (auto [v, w] : adj[u]) {
            long long new_dist = dist[u] + w;
            if (new_dist < dist[v]) {
                dist[v] = new_dist;
                buckets[new_dist % (k + 1)].push_back(v);
            }
        }
        
        current_dist++;
    }
    
    return dist;
}
```

**Когда использовать:** граф с pequeños весами (до $10^3$), когда Дейкстра медленнее.

---

# Алгоритм Дейкстры {id: "dijkstra"}

**Условие:** граф с **неотрицательными весами**.

```mermaid
graph LR
    A["Выбираем непосещённую<br/>вершину с мин. dist"]
    B["Расслабляем рёбра"]
    C["Все вершины<br/>посещены?"]
    A --> B
    B --> C
    C -->|Нет| A
    C -->|Да| D["Готово"]
    
    classDef process fill:#0066cc,stroke:#003366,color:#fff
    class A,B process
```

## Реализация с приоритетной очередью O((V+E) log V)

```cpp
vector<long long> dijkstra(vector<vector<pair<int, long long>>>& adj, int start, int n) {
    vector<long long> dist(n, LLONG_MAX);
    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;
    
    dist[start] = 0;
    pq.push({0, start});
    
    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();
        
        if (d > dist[u]) continue; // уже обработан с меньшей дистанцией
        
        for (auto [v, w] : adj[u]) {
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }
    
    return dist;
}
```

## Реализация O(V²) без приоритетной очереди

```cpp
vector<long long> dijkstra_v2(vector<vector<pair<int, long long>>>& adj, int start, int n) {
    vector<long long> dist(n, LLONG_MAX);
    vector<bool> used(n, false);
    dist[start] = 0;
    
    for (int i = 0; i < n; i++) {
        int u = -1;
        for (int j = 0; j < n; j++) {
            if (!used[j] && (u == -1 || dist[j] < dist[u])) {
                u = j;
            }
        }
        
        if (dist[u] == LLONG_MAX) break;
        used[u] = true;
        
        for (auto [v, w] : adj[u]) {
            dist[v] = min(dist[v], dist[u] + w);
        }
    }
    
    return dist;
}
```

**Выбор:**
- $O((V+E) \log V)$ для больших графов
- $O(V^2)$ для плотных графов или когда $V$ мала

---

# Беллман-Форд {id: "bellman-ford"}

Работает с **отрицательными весами**, может обнаружить **отрицательные циклы**.

**Идея:** расслабляем рёбра $V-1$ раз. На $V$-й итерации, если изменилось — цикл отрицательный.

```cpp
vector<long long> bellman_ford(int n, vector<tuple<int, int, long long>>& edges, int start) {
    vector<long long> dist(n, LLONG_MAX);
    dist[start] = 0;
    
    // Релаксируем V-1 раз
    for (int i = 0; i < n - 1; i++) {
        for (auto [u, v, w] : edges) {
            if (dist[u] != LLONG_MAX && dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
            }
        }
    }
    
    // Проверка отрицательного цикла
    vector<bool> in_cycle(n, false);
    for (auto [u, v, w] : edges) {
        if (dist[u] != LLONG_MAX && dist[u] + w < dist[v]) {
            in_cycle[v] = true;
        }
    }
    
    // Распространяем отрицательный цикл
    for (int i = 0; i < n; i++) {
        for (auto [u, v, w] : edges) {
            if (in_cycle[u]) in_cycle[v] = true;
        }
    }
    
    // Отмечаем расстояния до вершин в отрицательном цикле как -INF
    for (int i = 0; i < n; i++) {
        if (in_cycle[i]) dist[i] = LLONG_MIN / 2;
    }
    
    return dist;
}
```

**Сложность:** $O(VE)$

---

## Беллман-Форд на очереди (SPFA)

Оптимизация: обновляем только если узел был релаксирован на последней итерации.

```cpp
vector<long long> spfa(vector<vector<pair<int, long long>>>& adj, int start, int n) {
    vector<long long> dist(n, LLONG_MAX);
    vector<int> cnt(n, 0); // счётчик обновлений
    vector<bool> in_queue(n, false);
    queue<int> q;
    
    dist[start] = 0;
    q.push(start);
    in_queue[start] = true;
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        in_queue[u] = false;
        
        for (auto [v, w] : adj[u]) {
            if (dist[u] != LLONG_MAX && dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                cnt[v]++;
                
                if (cnt[v] > n) {
                    // Отрицательный цикл
                    return vector<long long>(n, LLONG_MIN);
                }
                
                if (!in_queue[v]) {
                    q.push(v);
                    in_queue[v] = true;
                }
            }
        }
    }
    
    return dist;
}
```

**Сложность:** $O(VE)$ в худшем, $O(E)$ в среднем.

---

# Флойд-Уоршелл {id: "floyd-warshall"}

Для **всех пар вершин** одновременно. Работает с отрицательными весами (но не циклами).

```cpp
void floyd_warshall(vector<vector<long long>>& dist, int n) {
    // dist[i][j] = кратчайшее расстояние от i к j
    // Инициализируем: dist[i][i] = 0, остальные = INF или веса рёбер
    
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][k] != LLONG_MAX && dist[k][j] != LLONG_MAX) {
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                }
            }
        }
    }
}
```

**Сложность:** $O(V^3)$ — не масштабируется для больших графов!

**Когда использовать:** $V \leq 500$.

---

# Обнаружение отрицательных циклов {id: "negative-cycles"}

## Метод 1: Беллман-Форд + проверка

После $V-1$ итераций пытаемся ещё раз. Если что-то изменилось — цикл.

## Метод 2: Флойд-Уоршелл

После алгоритма проверяем диагональ: если $dist[i][i] < 0$ — цикл.

```cpp
bool has_negative_cycle_fw(vector<vector<long long>>& dist, int n) {
    floyd_warshall(dist, n);
    for (int i = 0; i < n; i++) {
        if (dist[i][i] < 0) return true;
    }
    return false;
}
```

## Метод 3: DFS + состояния окраски

Используем три состояния: белый (непосещённый), серый (в стеке), чёрный (завершён).
Если встретили серую вершину — цикл.

```cpp
bool has_negative_cycle_dfs(vector<vector<pair<int, long long>>>& adj, int n) {
    enum Color { WHITE = 0, GRAY = 1, BLACK = 2 };
    vector<int> color(n, WHITE);
    
    function<bool(int)> dfs = [&](int u) {
        color[u] = GRAY;
        for (auto [v, w] : adj[u]) {
            if (color[v] == GRAY) {
                return true; // цикл
            }
            if (color[v] == WHITE && dfs(v)) {
                return true;
            }
        }
        color[u] = BLACK;
        return false;
    };
    
    for (int i = 0; i < n; i++) {
        if (color[i] == WHITE && dfs(i)) {
            return true;
        }
    }
    return false;
}
```

---

# Практические примеры {id: "examples"}

## Пример 1: Лабиринт с пошлиной

Граф — сетка. Горизонтальные/вертикальные переходы = 0, диагональные = 1.

**Решение:** 0-1 BFS.

```cpp
// Используем zero_one_bfs с рёбрами веса 0 и 1
```

## Пример 2: Обнаружение арбитража (отрицательного цикла)

Валюты и курсы обмена. Если существует последовательность обменов, дающая прибыль — это отрицательный цикл в логарифмическом масштабе.

**Решение:** SPFA для обнаружения.

```cpp
// Логарифмируем: dist[v] = min(dist[v], dist[u] + log(weight))
// Ищем отрицательные циклы в SPFA
```

## Пример 3: Кратчайшие расстояния между всеми аэропортами

$V \approx 50000$, нужны расстояния от одного аэропорта к 5 другим.

**Решение:** 5× Дейкстра, не Флойд-Уоршелл!

---

# Таблица выбора алгоритма {id: "algorithm-choice"}

| Задача | Граф | Алгоритм | Сложность |
|--------|------|----------|-----------|
| Кратчайший путь от одного | Неотрицательные веса | Dijkstra | $(V+E) \log V$ |
| Кратчайший путь от одного | Отрицательные, без циклов | Беллман-Форд или SPFA | $VE$ или $E$ |
| Все пары | $V \leq 500$ | Флойд-Уоршелл | $V^3$ |
| Все пары | $V$ велико | V раз Дейкстра | $V(V+E)\log V$ |
| 0-1 рёбра | Двоичные веса | 0-1 BFS | $V+E$ |
| Обнаружить отрицательный цикл | Любые | Беллман-Форд или SPFA | $VE$ |

---

$\text{От ученика для учеников.}\\ \text{\textcolor{red}{С любовью} к \textcolor{yellow}{Т-Образованию}.}\\ \textcolor{cyan}{Вадим\ Христенко.}$

---
title: "–ü–∞—Ä–∞–ª–ª–µ–ª—å B-X<br>–•–∞—Ä–¥—ã: –ü–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–∞—è –æ—á–µ—Ä–µ–¥—å –∏ —Å–ª–∏–≤–∞–µ–º—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã"
timestamp: 2025-10-07T17:45:00+03:00
last_updated_timestamp: 2025-10-18T20:30:00+03:00
series: "T-–û–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ"
tags:
  - Tbank
  - Tgeneration
  - HardLevel
  - PersistentQueue
  - MergingStructures
  - SkipLists
description: >-
  –ü–æ–Ω—è—Ç–Ω–æ, –¥–æ—Å—Ç—É–ø–Ω–æ –∏ –¥–µ—Ç–∞–ª—å–Ω–æ –æ —Ç–æ–º –ß–∞–í–æ –≤–æ–æ–±—â–µ —Ç–∞–∫–æ–µ –ü–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–∞—è –æ—á–µ—Ä–µ–¥—å.
  –ö–∞–∫ –≤–æ–æ–±—â–µ —Ä–∞–±–æ—Ç–∞—é—Ç —Å–ª–∏–≤–∞–µ–º—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã. –û —á—ë–º –≤–æ–æ–±—â–µ —Å–ø–∏—Å–∫–∏ —Å –ø—Ä–æ–ø—É—Å–∫–∞–º–∏.
  –ö–∞–∫ –≤—Å—ë —ç—Ç–æ —Ä–µ–∞–ª–∏–∑—É–µ—Ç—Å—è –Ω–∞ –ø—Ä–∞–∫—Ç–∏–∫–µ. –ò –¥–ª—è —á–µ–≥–æ —ç—Ç–æ –≤—Å—ë –Ω—É–∂–Ω–æ.
contents: true
---

<h2>–¢–µ–º–∞ –∫–æ–Ω—Å–ø–µ–∫—Ç–∞: –ü–µ—Ä—Å–∏—Å—Ç–Ω–∞—è –æ—á–µ—Ä–µ–¥—å, –°–∫–∏–ø –ª–∏—Å—Ç–∏–∫–∏ –∏ –°–ª–∏–≤–∞–µ–º—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–∫–∏</h2>

> **–ì–ª–∞–≤–Ω—ã–π –∞–≤—Ç–æ—Ä:** –í–∞–¥–∏–º –•—Ä–∏—Å—Ç–µ–Ω–∫–æ  
> **–î—Ä—É–≥–∏–µ –∞–≤—Ç–æ—Ä—ã:** ‚Äî  
> **–ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ:** 2025-10-15  
> **–°—Å—ã–ª–∫–∞ –Ω–∞ –æ–±—Å—É–∂–¥–µ–Ω–∏–µ:** *–î–ª—è —Ö–∞—Ä–¥–æ–≤ —Å—Å—ã–ª–∫–∏ –Ω–∞ –æ–±—Å—É–∂–¥–µ–Ω–∏–µ –ø–æ–∫–∞ —á—Ç–æ –Ω–µ—Ç.*  
> _–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:_ –≠—Ç–æ—Ç –∫–æ–Ω—Å–ø–µ–∫—Ç ‚Äî —á–∞—Å—Ç—å —Ç–æ–≥–æ —á—Ç–æ –¥–∞—ë—Ç T-–û–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å–∞–º–æ–π —Å–∏–ª—å–Ω–æ–π –ø–∞—Ä–∞–ª–ª–µ–ª–∏ –≤ X.  
> _–¢–µ–≥–∏:_ PersistentQueue, SkipLists, MergingStructures, –°–∫–∏–ø –ª–∏—Å—Ç—ã, –ü–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–∞—è –æ—á–µ—Ä–µ–¥—å, –°–ª–∏–≤–∞–µ–º—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

# –í–≤–µ–¥–µ–Ω–∏–µ {id: "introduction"}

–í —ç—Ç–æ–º –∫–æ–Ω—Å–ø–µ–∫—Ç–µ –º—ã —Ä–∞–∑–±–µ—Ä—ë–º —Ç—Ä–∏ –≤–∞–∂–Ω—ã–µ —Ç–µ–º—ã –∏–∑ –æ–±–ª–∞—Å—Ç–∏ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–Ω—ã—Ö:

1. **–ü–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö** ‚Äî –∫–∞–∫ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å –∏—Å—Ç–æ—Ä–∏—é –∏–∑–º–µ–Ω–µ–Ω–∏–π —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ
2. **–°–∫–∏–ø-–ª–∏—Å—Ç—ã** ‚Äî –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–Ω–∞—è –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞ —Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º –¥–µ—Ä–µ–≤—å—è–º
3. **–°–ª–∏–≤–∞–µ–º—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã** ‚Äî –∫–∞–∫ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ –æ–±—ä–µ–¥–∏–Ω—è—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö

–≠—Ç–∏ —Ç–µ–º—ã —Å–≤—è–∑–∞–Ω—ã –æ–±—â–µ–π –∏–¥–µ–µ–π: **—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã–º–∏** –ø—Ä–∏ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è—Ö –∫ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∏ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏.

---

# –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ {id: "contents"}

1. [–ü–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö](#persistent-structures)
   - [–ß—Ç–æ —Ç–∞–∫–æ–µ –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å](#what-is-persistence)
   - [–¢–∏–ø—ã –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏](#types-of-persistence)
   - [–ü–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–∞—è –æ—á–µ—Ä–µ–¥—å](#persistent-queue)
   - [–ü–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ã–π –º–∞—Å—Å–∏–≤](#persistent-array)
   
2. [–°–∫–∏–ø-–ª–∏—Å—Ç—ã (Skip Lists)](#skip-lists)
   - [–ú–æ—Ç–∏–≤–∞—Ü–∏—è –∏ –∏–¥–µ—è](#skip-lists-motivation)
   - [–°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å–∫–∏–ø-–ª–∏—Å—Ç–∞](#skip-list-structure)
   - [–û–ø–µ—Ä–∞—Ü–∏–∏ —Å–æ —Å–∫–∏–ø-–ª–∏—Å—Ç–∞–º–∏](#skip-list-operations)
   - [–ê–Ω–∞–ª–∏–∑ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏](#skip-list-complexity)
   
3. [–°–ª–∏–≤–∞–µ–º—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö](#mergeable-structures)
   - [–ß—Ç–æ —Ç–∞–∫–æ–µ —Å–ª–∏–≤–∞–µ–º—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã](#what-is-mergeable)
   - [–ë–∏–Ω–æ–º–∏–∞–ª—å–Ω—ã–µ –∫—É—á–∏](#binomial-heaps)
   - [–§–∏–±–æ–Ω–∞—á—á–∏–µ–≤—ã –∫—É—á–∏](#fibonacci-heaps)
   - [Leftist heaps](#leftist-heaps)
   
4. [–ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–æ–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ](#practical-applications)
5. [–ó–∞–¥–∞—á–∏ –¥–ª—è –ø—Ä–∞–∫—Ç–∏–∫–∏](#practice-problems)
6. [–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã](#additional-resources)

---

# –ü–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö {id: "persistent-structures"}

## –ß—Ç–æ —Ç–∞–∫–æ–µ –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å {id: "what-is-persistence"}

**–ü–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö** ‚Äî —ç—Ç–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞, –∫–æ—Ç–æ—Ä–∞—è —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –≤—Å–µ —Å–≤–æ–∏ –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –≤–µ—Ä—Å–∏–∏ –ø—Ä–∏ –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏. –í –æ—Ç–ª–∏—á–∏–µ –æ—Ç –æ–±—ã—á–Ω—ã—Ö (—ç—Ñ–µ–º–µ—Ä–Ω—ã—Ö) —Å—Ç—Ä—É–∫—Ç—É—Ä, –≥–¥–µ —Å—Ç–∞—Ä–∞—è –≤–µ—Ä—Å–∏—è —Ç–µ—Ä—è–µ—Ç—Å—è –ø–æ—Å–ª–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è.

### –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏

**–≠—Ñ–µ–º–µ—Ä–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞:**
```
[1, 2, 3] --push(4)--> [1, 2, 3, 4]
     ‚ùå                      ‚úÖ
  (–ø–æ—Ç–µ—Ä—è–Ω–∞)            (–¥–æ—Å—Ç—É–ø–Ω–∞)
```

**–ü–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞:**
```
[1, 2, 3] --push(4)--> [1, 2, 3, 4]
     ‚úÖ                      ‚úÖ
  (–¥–æ—Å—Ç—É–ø–Ω–∞)            (–¥–æ—Å—Ç—É–ø–Ω–∞)
```

### –ó–∞—á–µ–º –Ω—É–∂–Ω–∞ –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å?

1. **–û—Ç–∫–∞—Ç –∏–∑–º–µ–Ω–µ–Ω–∏–π (Undo/Redo)** ‚Äî —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Ä–µ–¥–∞–∫—Ç–æ—Ä—ã, –≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–µ —Ä–µ–¥–∞–∫—Ç–æ—Ä—ã
2. **–í–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ** ‚Äî Git, —Å–∏—Å—Ç–µ–º—ã –∫–æ–Ω—Ç—Ä–æ–ª—è –≤–µ—Ä—Å–∏–π
3. **–§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ** ‚Äî –∏–º–º—É—Ç–∞–±–µ–ª—å–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö
4. **–ö–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω–æ—Å—Ç—å** ‚Äî –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –¥–æ—Å—Ç—É–ø –∏–∑ —Ä–∞–∑–Ω—ã—Ö –ø–æ—Ç–æ–∫–æ–≤
5. **–û—Ç–ª–∞–¥–∫–∞** ‚Äî –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∏—Å—Å–ª–µ–¥–æ–≤–∞—Ç—å –∏—Å—Ç–æ—Ä–∏—é —Å–æ—Å—Ç–æ—è–Ω–∏–π

---

## –¢–∏–ø—ã –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏ {id: "types-of-persistence"}

### –ß–∞—Å—Ç–∏—á–Ω–∞—è –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å (Partially Persistent)

- –ú–æ–∂–Ω–æ —á–∏—Ç–∞—Ç—å –∏–∑ –ª—é–±–æ–π –≤–µ—Ä—Å–∏–∏
- –ú–æ–∂–Ω–æ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω—é—é –≤–µ—Ä—Å–∏—é

```mermaid
graph LR
    V0[–í–µ—Ä—Å–∏—è 0] --> V1[–í–µ—Ä—Å–∏—è 1]
    V1 --> V2[–í–µ—Ä—Å–∏—è 2]
    V2 --> V3[–í–µ—Ä—Å–∏—è 3]
    
    V0 -.—á—Ç–µ–Ω–∏–µ.-> R0[ ]
    V1 -.—á—Ç–µ–Ω–∏–µ.-> R1[ ]
    V2 -.—á—Ç–µ–Ω–∏–µ.-> R2[ ]
    V3 -.–∑–∞–ø–∏—Å—å.-> W3[‚úèÔ∏è]
    
    style V3 fill:green
    style W3 fill:yellow
```

### –ü–æ–ª–Ω–∞—è –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å (Fully Persistent)

- –ú–æ–∂–Ω–æ —á–∏—Ç–∞—Ç—å –∏–∑ –ª—é–±–æ–π –≤–µ—Ä—Å–∏–∏
- –ú–æ–∂–Ω–æ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å –ª—é–±—É—é –≤–µ—Ä—Å–∏—é (—Å–æ–∑–¥–∞–≤–∞—è –Ω–æ–≤—É—é –≤–µ—Ç–∫—É)

```mermaid
graph TB
    V0[–í–µ—Ä—Å–∏—è 0] --> V1[–í–µ—Ä—Å–∏—è 1]
    V0 --> V2[–í–µ—Ä—Å–∏—è 2]
    V1 --> V3[–í–µ—Ä—Å–∏—è 3]
    V2 --> V4[–í–µ—Ä—Å–∏—è 4]
    V3 --> V5[–í–µ—Ä—Å–∏—è 5]
    
    style V0 fill:cyan
    style V1 fill:green
    style V2 fill:pink
    style V3 fill:green
    style V4 fill:pink
    style V5 fill:green
```

### –ö–æ–Ω—Ñ–ª—é—ç–Ω—Ç–Ω–∞—è –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å (Confluently Persistent)

- –ü–æ–ª–Ω–∞—è –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å + –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —Å–ª–∏—è–Ω–∏—è –≤–µ—Ä—Å–∏–π

```mermaid
graph TB
    V0[–í–µ—Ä—Å–∏—è 0] --> V1[–í–µ—Ä—Å–∏—è 1]
    V0 --> V2[–í–µ—Ä—Å–∏—è 2]
    V1 --> V3[–í–µ—Ä—Å–∏—è 3]
    V2 --> V3
    V3 --> V4[–í–µ—Ä—Å–∏—è 4]
    
    style V3 fill:yellow
```

---

## –ü–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–∞—è –æ—á–µ—Ä–µ–¥—å {id: "persistent-queue"}

### –ù–∞–∏–≤–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è

**–ü—Ä–æ–±–ª–µ–º–∞:** –ï—Å–ª–∏ –ø—Ä–æ—Å—Ç–æ –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤–µ—Å—å –º–∞—Å—Å–∏–≤ –ø—Ä–∏ –∫–∞–∂–¥–æ–π –æ–ø–µ—Ä–∞—Ü–∏–∏:

```pseudocode
class NaivePersistentQueue<T>:
    data: vector<T>
    
    func __init__(data: vector<T> | null):
        self.data = data if data != null else vector<T>()
    
    func push(value: T) -> NaivePersistentQueue<T>:
        # O(n) - –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ–≥–æ –º–∞—Å—Å–∏–≤–∞ ‚ùå
        return new NaivePersistentQueue<T>(self.data + [value])
    
    func pop() -> (NaivePersistentQueue<T>, T | null):
        # O(n) - –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ–≥–æ –º–∞—Å—Å–∏–≤–∞ ‚ùå
        if self.data.is_empty():
            return (self, null)
        return (new NaivePersistentQueue<T>(self.data[1:]), self.data[0])
```

**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** $O(n)$ –¥–ª—è –∫–∞–∂–¥–æ–π –æ–ø–µ—Ä–∞—Ü–∏–∏ ‚Äî –Ω–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ! üòû

### –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ –¥–≤–∞ —Å—Ç–µ–∫–∞

**–ò–¥–µ—è:** –ü—Ä–µ–¥—Å—Ç–∞–≤–∏–º –æ—á–µ—Ä–µ–¥—å –∫–∞–∫ –¥–≤–∞ —Å–ø–∏—Å–∫–∞ (—Å—Ç–µ–∫–∞):
- **front** ‚Äî —ç–ª–µ–º–µ–Ω—Ç—ã –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è (–≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ)
- **rear** ‚Äî —ç–ª–µ–º–µ–Ω—Ç—ã –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è (–≤ –ø—Ä—è–º–æ–º –ø–æ—Ä—è–¥–∫–µ)

```mermaid
graph LR
    subgraph Queue
        subgraph Front Stack
            F3[3] --> F2[2] --> F1[1]
        end
        subgraph Rear Stack
            R1[4] --> R2[5] --> R3[6]
        end
    end
    
    style F1 fill:green
    style R3 fill:pink
```

**–ò–Ω–≤–∞—Ä–∏–∞–Ω—Ç:** –≠–ª–µ–º–µ–Ω—Ç—ã –∏–∑–≤–ª–µ–∫–∞—é—Ç—Å—è –∏–∑ `front`, –µ—Å–ª–∏ `front` –ø—É—Å—Ç ‚Äî –ø–µ—Ä–µ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º `rear` –≤ `front`.

### –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞

–î–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–π —Ä–∞–±–æ—Ç—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º **—Å—Ç—Ä—É–∫—Ç—É—Ä–Ω–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ (structural sharing)**:

```mermaid
graph TB
    subgraph "–í–µ—Ä—Å–∏—è 2: [3,2,1]"
        V2_3[3] --> V1_2
    end
    
    subgraph "–í–µ—Ä—Å–∏—è 1: [2,1]"
        V1_2[2] --> V0_1
    end
    
    subgraph "–í–µ—Ä—Å–∏—è 0: [1]"
        V0_1[1] --> Nil1[nil]
    end

    style V2_3 fill:yellow
    style V1_2 fill:green
    style V0_1 fill:cyan
```

**–ö–æ–¥:**

```pseudocode
class PersistentList<T>:
    head: T | null
    tail: PersistentList<T> | null
    
    func __init__(head: T | null, tail: PersistentList<T> | null):
        self.head = head
        self.tail = tail
    
    func is_empty() -> bool:
        return self.head == null
    
    func cons(value: T) -> PersistentList<T>:
        # –î–æ–±–∞–≤–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –≤ –Ω–∞—á–∞–ª–æ - O(1)
        return new PersistentList<T>(value, self)
    
    func car() -> T:
        # –ü–æ–ª—É—á–∏—Ç—å –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç - O(1)
        if self.is_empty():
            raise IndexError("Empty list")
        return self.head
    
    func cdr() -> PersistentList<T>:
        # –ü–æ–ª—É—á–∏—Ç—å —Ö–≤–æ—Å—Ç —Å–ø–∏—Å–∫–∞ - O(1)
        if self.is_empty():
            raise IndexError("Empty list")
        return self.tail if self.tail != null else new PersistentList<T>(null, null)
    
    static func reverse(lst: PersistentList<T>) -> PersistentList<T>:
        # –†–∞–∑–≤–µ—Ä–Ω—É—Ç—å —Å–ø–∏—Å–æ–∫ - O(n)
        var result: PersistentList<T> = new PersistentList<T>(null, null)
        var current = lst
        while !current.is_empty():
            result = result.cons(current.car())
            current = current.cdr()
        return result
```

### –ü–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–∞—è –æ—á–µ—Ä–µ–¥—å –Ω–∞ –¥–≤—É—Ö —Å—Ç–µ–∫–∞—Ö

```pseudocode
class PersistentQueue<T>:
    # –ü–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–∞—è –æ—á–µ—Ä–µ–¥—å —á–µ—Ä–µ–∑ –¥–≤–∞ –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ã—Ö —Å–ø–∏—Å–∫–∞
    # –ê–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å –æ–ø–µ—Ä–∞—Ü–∏–π: O(1)
    
    front: PersistentList<T>
    rear: PersistentList<T>
    
    func __init__(front: PersistentList<T> | null, rear: PersistentList<T> | null):
        self.front = front if front != null else new PersistentList<T>(null, null)
        self.rear = rear if rear != null else new PersistentList<T>(null, null)
        self._normalize()
    
    func _normalize() -> void:
        # –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º –∏–Ω–≤–∞—Ä–∏–∞–Ω—Ç: front –Ω–µ –ø—É—Å—Ç, –µ—Å–ª–∏ –µ—Å—Ç—å —ç–ª–µ–º–µ–Ω—Ç—ã
        if self.front.is_empty() && !self.rear.is_empty():
            self.front = PersistentList.reverse(self.rear)
            self.rear = new PersistentList<T>(null, null)
    
    func is_empty() -> bool:
        return self.front.is_empty()
    
    func enqueue(value: T) -> PersistentQueue<T>:
        # –î–æ–±–∞–≤–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –≤ –∫–æ–Ω–µ—Ü - O(1)
        var new_rear = self.rear.cons(value)
        var result = new PersistentQueue<T>(self.front, new_rear)
        return result
    
    func dequeue() -> tuple(PersistentQueue<T>, T):
        # –ò–∑–≤–ª–µ—á—å —ç–ª–µ–º–µ–Ω—Ç –∏–∑ –Ω–∞—á–∞–ª–∞ - O(1) –∞–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ
        if self.is_empty():
            raise IndexError("Queue is empty")
        
        var value = self.front.car()
        var new_front = self.front.cdr()
        var result = new PersistentQueue<T>(new_front, self.rear)
        return (result, value)
    
    func peek() -> T:
        # –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –±–µ–∑ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è - O(1)
        if self.is_empty():
            raise IndexError("Queue is empty")
        return self.front.car()
```

### –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è

```pseudocode
# –°–æ–∑–¥–∞—ë–º –ø—É—Å—Ç—É—é –æ—á–µ—Ä–µ–¥—å
var q0 = PersistentQueue<int>()

# –í–µ—Ä—Å–∏—è 1: –¥–æ–±–∞–≤–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã
var q1 = q0.enqueue(1)
var q2 = q1.enqueue(2)
var q3 = q2.enqueue(3)

# –í–µ—Ä—Å–∏—è 2: –∏–∑–≤–ª–µ–∫–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç
var (value, q4) = q3.dequeue()  # value = 1

# –í–µ—Ä—Å–∏—è 3: –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ä–∞–±–æ—Ç–∞—Ç—å —Å q3 (–≤–µ—Ç–≤–ª–µ–Ω–∏–µ!)
var q5 = q3.enqueue(4)

# –í—Å–µ –≤–µ—Ä—Å–∏–∏ –¥–æ—Å—Ç—É–ø–Ω—ã:
output q3.peek()  # 1
output q4.peek()  # 2
output q5.peek()  # 1

# –ú–æ–∂–µ–º –ø—Ä–æ–¥–æ–ª–∂–∞—Ç—å —Ä–∞–±–æ—Ç–∞—Ç—å —Å –ª—é–±–æ–π –≤–µ—Ä—Å–∏–µ–π
var q6 = q4.enqueue(5)
```

### –ê–Ω–∞–ª–∏–∑ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏

**–ê–º–æ—Ä—Ç–∏–∑–∞—Ü–∏–æ–Ω–Ω—ã–π –∞–Ω–∞–ª–∏–∑:**

–†–∞—Å—Å–º–æ—Ç—Ä–∏–º –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∏–∑ $n$ –æ–ø–µ—Ä–∞—Ü–∏–π:
- –ö–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç –¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è –≤ `rear` –∑–∞ $O(1)$
- –ü—Ä–∏ –ø–µ—Ä–µ–Ω–æ—Å–µ –≤ `front` (reverse) –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è –æ–¥–∏–Ω —Ä–∞–∑
- –°—É–º–º–∞—Ä–Ω–æ: $O(n)$ –æ–ø–µ—Ä–∞—Ü–∏–π –¥–ª—è $n$ —ç–ª–µ–º–µ–Ω—Ç–æ–≤

**–ê–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å:**

$$T_{amortized} = \frac{O(n)}{n} = O(1)$$

**–¢–∞–±–ª–∏—Ü–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏:**

| –û–ø–µ—Ä–∞—Ü–∏—è | –•—É–¥—à–∏–π —Å–ª—É—á–∞–π | –ê–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ | –ü–∞–º—è—Ç—å –Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—é |
|----------|--------------|-----------------|-------------------|
| `enqueue` | $O(1)$ | $O(1)$ | $O(1)$ |
| `dequeue` | $O(n)$ | $O(1)$ | $O(1)$ |
| `peek` | $O(1)$ | $O(1)$ | $O(1)$ |
| `is_empty` | $O(1)$ | $O(1)$ | $O(1)$ |

---

## –ü–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ã–π –º–∞—Å—Å–∏–≤ {id: "persistent-array"}

### –ü—Ä–æ–±–ª–µ–º–∞

–û–±—ã—á–Ω—ã–π –º–∞—Å—Å–∏–≤ –Ω–µ –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏:
- –ò–∑–º–µ–Ω–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–∞ —Ç—Ä–µ–±—É–µ—Ç –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –≤—Å–µ–≥–æ –º–∞—Å—Å–∏–≤–∞: $O(n)$

### –†–µ—à–µ–Ω–∏–µ: Fat Node

**–ò–¥–µ—è:** –•—Ä–∞–Ω–∏–º –∏—Å—Ç–æ—Ä–∏—é –∏–∑–º–µ–Ω–µ–Ω–∏–π –∫–∞–∂–¥–æ–π —è—á–µ–π–∫–∏

```pseudocode
class FatNodeArray<T>:
    # –ü–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ã–π –º–∞—Å—Å–∏–≤ —á–µ—Ä–µ–∑ Fat Node –º–µ—Ç–æ–¥
    
    data: vector< vector< pair(int, T) > >
    version: int
    
    func __init__(size: int):
        self.data = vector(size)  # –ö–∞–∂–¥–∞—è —è—á–µ–π–∫–∞ —Ö—Ä–∞–Ω–∏—Ç (–≤–µ—Ä—Å–∏—è, –∑–Ω–∞—á–µ–Ω–∏–µ)
        self.version = 0
        for i in 0..size:
            self.data[i] = vector()
            self.data[i].push_back(pair(-1, null))
    
    func get(index: int, version: int | null) -> T:
        # –ü–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–∞ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–π –≤–µ—Ä—Å–∏–∏ - O(log V)
        if version == null:
            version = self.version
        
        var history = self.data[index]
        var left = 0
        var right = len(history) - 1
        var result: T = null
        
        # –ë–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫ –ø–æ –≤–µ—Ä—Å–∏—è–º
        while left <= right:
            var mid = (left + right) / 2
            if history[mid].first <= version:
                result = history[mid].second
                left = mid + 1
            else:
                right = mid - 1
        
        return result
    
    func set(index: int, value: T) -> int:
        # –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ (—Å–æ–∑–¥–∞—ë—Ç –Ω–æ–≤—É—é –≤–µ—Ä—Å–∏—é) - O(1)
        self.version += 1
        self.data[index].push_back(pair(self.version, value))
        return self.version
```

### Path Copying (–±–æ–ª–µ–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ)

–ò—Å–ø–æ–ª—å–∑—É–µ–º **–¥–µ—Ä–µ–≤–æ** –≤–º–µ—Å—Ç–æ –º–∞—Å—Å–∏–≤–∞ –¥–ª—è —É–º–µ–Ω—å—à–µ–Ω–∏—è –æ–±—ä—ë–º–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è:

```mermaid
graph TB
    subgraph "–í–µ—Ä—Å–∏—è 1"
        Root1[Root v1]
        Root1 --> A1[A]
        Root1 --> B1[B]
        A1 --> C1[C]
        A1 --> D1[D]
        B1 --> E1[E]
        B1 --> F1[F]
    end
    
    style D1 fill:yellow
```

–ü—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —ç–ª–µ–º–µ–Ω—Ç–∞ `D`:

```mermaid
graph TB
    subgraph "–í–µ—Ä—Å–∏—è 2"
        Root2[Root v2] -.–∫–æ–ø–∏—è.-> Root1[Root v1]
        Root2 --> A2[A']
        Root2 --> B2[B]
        A2 --> C2[C]
        A2 --> D2[D']
        B2 --> E2[E]
        B2 --> F2[F]
    end
    
    style Root2 fill:green
    style A2 fill:green
    style D2 fill:yellow
```

–ö–æ–ø–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ **–ø—É—Ç—å –æ—Ç –∫–æ—Ä–Ω—è –¥–æ –∏–∑–º–µ–Ω—ë–Ω–Ω–æ–≥–æ —É–∑–ª–∞**: $O(\log n)$

---

# –°–∫–∏–ø-–ª–∏—Å—Ç—ã (Skip Lists) {id: "skip-lists"}

## –ú–æ—Ç–∏–≤–∞—Ü–∏—è –∏ –∏–¥–µ—è {id: "skip-lists-motivation"}

### –ü—Ä–æ–±–ª–µ–º–∞ –ø–æ–∏—Å–∫–∞ –≤ —Å–≤—è–∑–Ω–æ–º —Å–ø–∏—Å–∫–µ

**–û–±—ã—á–Ω—ã–π –æ–¥–Ω–æ—Å–≤—è–∑–Ω—ã–π —Å–ø–∏—Å–æ–∫:**

```mermaid
graph LR
    H[Head] --> N1[1] --> N2[7] --> N3[12] --> N4[19] --> N5[25] --> N6[31] --> N7[42]
    
    style N6 fill:yellow
```

**–ü–æ–∏—Å–∫ —ç–ª–µ–º–µ–Ω—Ç–∞ 31:** –Ω—É–∂–Ω–æ –ø—Ä–æ–π—Ç–∏ –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã ‚Äî $O(n)$

### –ò–¥–µ—è: –¥–æ–±–∞–≤–∏–º "—ç–∫—Å–ø—Ä–µ—Å—Å-–ø–æ–ª–æ—Å—ã"

**–°–∫–∏–ø-–ª–∏—Å—Ç —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ —É—Ä–æ–≤–Ω—è–º–∏:**

```mermaid
graph TB
    subgraph "–£—Ä–æ–≤–µ–Ω—å 3 (1/8 —ç–ª–µ–º–µ–Ω—Ç–æ–≤)"
        H3[H3] --> L3_1[1] --> L3_2[25]
    end
    
    subgraph "–£—Ä–æ–≤–µ–Ω—å 2 (1/4 —ç–ª–µ–º–µ–Ω—Ç–æ–≤)"
        H2[H2] --> L2_1[1] --> L2_2[12] --> L2_3[25] --> L2_4[42]
    end
    
    subgraph "–£—Ä–æ–≤–µ–Ω—å 1 (1/2 —ç–ª–µ–º–µ–Ω—Ç–æ–≤)"
        H1[H1] --> L1_1[1] --> L1_2[7] --> L1_3[12] --> L1_4[19] --> L1_5[25] --> L1_6[31] --> L1_7[42]
    end
    
    subgraph "–£—Ä–æ–≤–µ–Ω—å 0 (–≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã)"
        H0[H0] --> L0_1[1] --> L0_2[7] --> L0_3[12] --> L0_4[19] --> L0_5[25] --> L0_6[31] --> L0_7[42]
    end
    
    L3_1 -.-> L2_1 -.-> L1_1 -.-> L0_1
    L3_2 -.-> L2_3 -.-> L1_5 -.-> L0_5
    L2_2 -.-> L1_3 -.-> L0_3
    L2_4 -.-> L1_7 -.-> L0_7
    
    style L0_6 fill:yellow
    style L1_6 fill:yellow
```

**–ü–æ–∏—Å–∫ —ç–ª–µ–º–µ–Ω—Ç–∞ 31:** –¥–≤–∏–∂–µ–º—Å—è –ø–æ –≤–µ—Ä—Ö–Ω–∏–º —É—Ä–æ–≤–Ω—è–º, —Å–ø—É—Å–∫–∞—è—Å—å –≤–Ω–∏–∑ ‚Äî $O(\log n)$

---

## –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å–∫–∏–ø-–ª–∏—Å—Ç–∞ {id: "skip-list-structure"}

### –£–∑–µ–ª —Å–∫–∏–ø-–ª–∏—Å—Ç–∞

```pseudocode
class SkipNode<K, V>:
    # –£–∑–µ–ª —Å–∫–∏–ø-–ª–∏—Å—Ç–∞
    
    key: K
    value: V
    forward: vector< SkipNode<K, V> | null >  # –£–∫–∞–∑–∞—Ç–µ–ª–∏ –Ω–∞ –∫–∞–∂–¥—ã–π —É—Ä–æ–≤–µ–Ω—å
    
    func __init__(key: K, value: V, level: int):
        self.key = key
        self.value = value
        self.forward = vector(level + 1)  # –ú–∞—Å—Å–∏–≤ —É–∫–∞–∑–∞—Ç–µ–ª–µ–π
        for i in 0..level + 1:
            self.forward[i] = null

class SkipList<K, V>:
    # –°–∫–∏–ø-–ª–∏—Å—Ç –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ —É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã–º –∫–ª—é—á–∞–º
    
    max_level: int
    p: float
    level: int
    header: SkipNode<K, V>
    
    func __init__(max_level: int = 16, p: float = 0.5):
        self.max_level = max_level      # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –≤—ã—Å–æ—Ç–∞
        self.p = p                      # –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø–æ–≤—ã—à–µ–Ω–∏—è —É—Ä–æ–≤–Ω—è
        self.level = 0                  # –¢–µ–∫—É—â–∞—è –≤—ã—Å–æ—Ç–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
        self.header = new SkipNode<K, V>(-inf, null, max_level)  # Sentinel —É–∑–µ–ª
    
    func random_level() -> int:
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–ª—É—á–∞–π–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å –¥–ª—è –Ω–æ–≤–æ–≥–æ —É–∑–ª–∞
        # –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –≥–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º p
        var lvl = 0
        while random() < self.p && lvl < self.max_level:
            lvl += 1
        return lvl
```

### –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

–î–ª—è —Å–∫–∏–ø-–ª–∏—Å—Ç–∞ —Å–æ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ `[1, 7, 12, 19, 25, 31, 42]`:

```
–£—Ä–æ–≤–µ–Ω—å 3:  HEAD --------------------------> 25 ----------------------> NULL
                 |                           |
–£—Ä–æ–≤–µ–Ω—å 2:  HEAD -------> 12 -------------> 25 -------> 42 ----------> NULL
                 |         |                 |           |
–£—Ä–æ–≤–µ–Ω—å 1:  HEAD -> 1 --> 12 -> 19 ------> 25 -> 31 --> 42 ----------> NULL
                 |  |      |     |          |     |      |
–£—Ä–æ–≤–µ–Ω—å 0:  HEAD -> 1 -> 7 -> 12 -> 19 --> 25 -> 31 --> 42 ----------> NULL
```

---

## –û–ø–µ—Ä–∞—Ü–∏–∏ —Å–æ —Å–∫–∏–ø-–ª–∏—Å—Ç–∞–º–∏ {id: "skip-list-operations"}

### –ü–æ–∏—Å–∫ (Search)

**–ê–ª–≥–æ—Ä–∏—Ç–º:**
1. –ù–∞—á–∏–Ω–∞–µ–º —Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ —É—Ä–æ–≤–Ω—è –≥–æ–ª–æ–≤–Ω–æ–≥–æ —É–∑–ª–∞
2. –î–≤–∏–≥–∞–µ–º—Å—è –≤–ø—Ä–∞–≤–æ, –ø–æ–∫–∞ —Å–ª–µ–¥—É—é—â–∏–π –∫–ª—é—á –º–µ–Ω—å—à–µ –∏—Å–∫–æ–º–æ–≥–æ
3. –°–ø—É—Å–∫–∞–µ–º—Å—è –Ω–∞ —É—Ä–æ–≤–µ–Ω—å –Ω–∏–∂–µ
4. –ü–æ–≤—Ç–æ—Ä—è–µ–º –ø–æ–∫–∞ –Ω–µ –Ω–∞–π–¥—ë–º –∏–ª–∏ –Ω–µ –¥–æ–π–¥—ë–º –¥–æ —É—Ä–æ–≤–Ω—è 0

```pseudocode
func search(key: K) -> V | null:
    # –ü–æ–∏—Å–∫ –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ –∫–ª—é—á—É - O(log n) –æ–∂–∏–¥–∞–µ–º–æ
    var current = self.header
    
    # –ò–¥—ë–º —Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑
    for i in range(self.level, -1, -1):
        # –î–≤–∏–≥–∞–µ–º—Å—è –≤–ø—Ä–∞–≤–æ, –ø–æ–∫–∞ –∫–ª—é—á –º–µ–Ω—å—à–µ –Ω—É–∂–Ω–æ–≥–æ
        while current.forward[i] != null && current.forward[i].key < key:
            current = current.forward[i]
    
    # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ —É—Ä–æ–≤–µ–Ω—å 0
    current = current.forward[0]
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—à–ª–∏ –ª–∏ —ç–ª–µ–º–µ–Ω—Ç
    if current != null && current.key == key:
        return current.value
    return null
```

**–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–∏—Å–∫–∞ –∫–ª—é—á–∞ 31:**

```
–£—Ä–æ–≤–µ–Ω—å 3:  HEAD -----[1]--------------------> 25 --[2]--> NULL
                                                |
–£—Ä–æ–≤–µ–Ω—å 2:  HEAD --------------------------> 25 -------> 42 --> NULL
                                                |
–£—Ä–æ–≤–µ–Ω—å 1:  HEAD --------------------------> 25 --[3]--> 31 --[4]--> 42
                                                          |
–£—Ä–æ–≤–µ–Ω—å 0:  HEAD --------------------------> 25 -------> 31 -------> 42
                                                          ‚úì
```

–®–∞–≥–∏:
1. –£—Ä–æ–≤–µ–Ω—å 3: `HEAD ‚Üí 25` (25 < 31, –∏–¥—ë–º –¥–∞–ª—å—à–µ)
2. –£—Ä–æ–≤–µ–Ω—å 3: `25 ‚Üí NULL` (–Ω–µ –º–æ–∂–µ–º –∏–¥—Ç–∏, —Å–ø—É—Å–∫–∞–µ–º—Å—è)
3. –£—Ä–æ–≤–µ–Ω—å 1: `25 ‚Üí 31` (–Ω–∞—à–ª–∏)

### –í—Å—Ç–∞–≤–∫–∞ (Insert)

**–ê–ª–≥–æ—Ä–∏—Ç–º:**
1. –ù–∞–π—Ç–∏ –ø–æ–∑–∏—Ü–∏—é –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏ (–∫–∞–∫ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ)
2. –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Å–ª—É—á–∞–π–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å –¥–ª—è –Ω–æ–≤–æ–≥–æ —É–∑–ª–∞
3. –í—Å—Ç–∞–≤–∏—Ç—å —É–∑–µ–ª –Ω–∞ –≤—Å–µ—Ö —É—Ä–æ–≤–Ω—è—Ö –æ—Ç 0 –¥–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ

```pseudocode
func insert(key: K, value: V) -> void:
    # –í—Å—Ç–∞–≤–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–∞ - O(log n) –æ–∂–∏–¥–∞–µ–º–æ
    var update: vector< SkipNode<K, V> > = vector(self.max_level + 1)
    var current = self.header
    
    # –ù–∞—Ö–æ–¥–∏–º –ø–æ–∑–∏—Ü–∏—é –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏ –∏ –∑–∞–ø–æ–º–∏–Ω–∞–µ–º –ø—Ä–µ–¥—à–µ—Å—Ç–≤–µ–Ω–Ω–∏–∫–æ–≤
    for i in range(self.level, -1, -1):
        while current.forward[i] != null && current.forward[i].key < key:
            current = current.forward[i]
        update[i] = current
    
    # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ —É—Ä–æ–≤–µ–Ω—å 0
    current = current.forward[0]
    
    # –ï—Å–ª–∏ –∫–ª—é—á —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –æ–±–Ω–æ–≤–ª—è–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ
    if current != null && current.key == key:
        current.value = value
        return
    
    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–ª—É—á–∞–π–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å
    var new_level = self.random_level()
    
    # –ï—Å–ª–∏ –Ω–æ–≤—ã–π —É—Ä–æ–≤–µ–Ω—å –±–æ–ª—å—à–µ —Ç–µ–∫—É—â–µ–≥–æ, –æ–±–Ω–æ–≤–ª—è–µ–º header
    if new_level > self.level:
        for i in range(self.level + 1, new_level + 1):
            update[i] = self.header
        self.level = new_level
    
    # –°–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π —É–∑–µ–ª
    var new_node = new SkipNode<K, V>(key, value, new_level)
    
    # –í—Å—Ç–∞–≤–ª—è–µ–º —É–∑–µ–ª –Ω–∞ –≤—Å–µ—Ö —É—Ä–æ–≤–Ω—è—Ö
    for i in range(0, new_level + 1):
        new_node.forward[i] = update[i].forward[i]
        update[i].forward[i] = new_node
```

**–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –≤—Å—Ç–∞–≤–∫–∏ –∫–ª—é—á–∞ 17 (—É—Ä–æ–≤–µ–Ω—å = 2):**

–î–æ –≤—Å—Ç–∞–≤–∫–∏:
```
–£—Ä–æ–≤–µ–Ω—å 2:  HEAD -> 12 -> 25 -> NULL
–£—Ä–æ–≤–µ–Ω—å 1:  HEAD -> 12 -> 19 -> 25 -> NULL
–£—Ä–æ–≤–µ–Ω—å 0:  HEAD -> 12 -> 19 -> 25 -> NULL
```

–ü–æ—Å–ª–µ –≤—Å—Ç–∞–≤–∫–∏:
```
–£—Ä–æ–≤–µ–Ω—å 2:  HEAD -> 12 -> [17] -> 25 -> NULL
                          ‚Üì
–£—Ä–æ–≤–µ–Ω—å 1:  HEAD -> 12 -> [17] -> 19 -> 25 -> NULL
                          ‚Üì
–£—Ä–æ–≤–µ–Ω—å 0:  HEAD -> 12 -> [17] -> 19 -> 25 -> NULL
```

### –£–¥–∞–ª–µ–Ω–∏–µ (Delete)

```pseudocode
func delete(key: K) -> bool:
    # –£–¥–∞–ª–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–∞ - O(log n) –æ–∂–∏–¥–∞–µ–º–æ
    var update: vector< SkipNode<K, V> > = vector(self.max_level + 1)
    var current = self.header
    
    # –ù–∞—Ö–æ–¥–∏–º —É–∑–µ–ª –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è
    for i in range(self.level, -1, -1):
        while current.forward[i] != null && current.forward[i].key < key:
            current = current.forward[i]
        update[i] = current
    
    current = current.forward[0]
    
    # –ï—Å–ª–∏ –Ω–∞—à–ª–∏ —É–∑–µ–ª, —É–¥–∞–ª—è–µ–º –µ–≥–æ —Å–æ –≤—Å–µ—Ö —É—Ä–æ–≤–Ω–µ–π
    if current != null && current.key == key:
        for i in range(0, self.level + 1):
            if update[i].forward[i] != current:
                break
            update[i].forward[i] = current.forward[i]
        
        # –£–º–µ–Ω—å—à–∞–µ–º —É—Ä–æ–≤–µ–Ω—å, –µ—Å–ª–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ
        while self.level > 0 && self.header.forward[self.level] == null:
            self.level -= 1
        
        delete current
        return true
    return false
```

---

## –ê–Ω–∞–ª–∏–∑ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ {id: "skip-list-complexity"}

### –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–Ω—ã–π –∞–Ω–∞–ª–∏–∑

**–í—ã—Å–æ—Ç–∞ —Å–∫–∏–ø-–ª–∏—Å—Ç–∞:**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å —Ç–æ–≥–æ, —á—Ç–æ —É–∑–µ–ª –∏–º–µ–µ—Ç —É—Ä–æ–≤–µ–Ω—å $k$:

$$P(\text{level} = k) = p^k \cdot (1-p)$$

–û–∂–∏–¥–∞–µ–º–∞—è –≤—ã—Å–æ—Ç–∞ –¥–ª—è $n$ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ø—Ä–∏ $p = \frac{1}{2}$:

$$E[H] = O(\log n)$$

**–î–ª–∏–Ω–∞ –ø—É—Ç–∏ –ø–æ–∏—Å–∫–∞:**

–ù–∞ –∫–∞–∂–¥–æ–º —É—Ä–æ–≤–Ω–µ –æ–∂–∏–¥–∞–µ–º–æ–µ —á–∏—Å–ª–æ —à–∞–≥–æ–≤:

$$E[\text{steps at level } i] = \frac{1}{p} = 2$$

–û–±—â–µ–µ –æ–∂–∏–¥–∞–µ–º–æ–µ —á–∏—Å–ª–æ —à–∞–≥–æ–≤:

$$E[\text{total steps}] = O(\log n) \cdot 2 = O(\log n)$$

### –¢–∞–±–ª–∏—Ü–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏

| –û–ø–µ—Ä–∞—Ü–∏—è | –û–∂–∏–¥–∞–µ–º–æ–µ –≤—Ä–µ–º—è | –•—É–¥—à–∏–π —Å–ª—É—á–∞–π | –ü–∞–º—è—Ç—å |
|----------|----------------|---------------|--------|
| Search | $O(\log n)$ | $O(n)$ | ‚Äî |
| Insert | $O(\log n)$ | $O(n)$ | $O(1)$ |
| Delete | $O(\log n)$ | $O(n)$ | ‚Äî |
| Space | ‚Äî | ‚Äî | $O(n \log n)$ –æ–∂–∏–¥–∞–µ–º–æ |

### –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å –¥—Ä—É–≥–∏–º–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º–∏

| –°—Ç—Ä—É–∫—Ç—É—Ä–∞ | Search | Insert | Delete | Worst Case | –ë–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∫–∞ |
|-----------|--------|--------|--------|------------|--------------|
| –°–∫–∏–ø-–ª–∏—Å—Ç | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | $O(n)$ | –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è (–≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–Ω–∞—è) |
| AVL –¥–µ—Ä–µ–≤–æ | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | –¢—Ä–µ–±—É–µ—Ç —Ä–æ—Ç–∞—Ü–∏–π |
| –ö—Ä–∞—Å–Ω–æ-—á—ë—Ä–Ω–æ–µ –¥–µ—Ä–µ–≤–æ | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | –¢—Ä–µ–±—É–µ—Ç —Ä–æ—Ç–∞—Ü–∏–π |
| B-–¥–µ—Ä–µ–≤–æ | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | –¢—Ä–µ–±—É–µ—Ç —Å–ª–∏—è–Ω–∏–π/—Ä–∞–∑–±–∏–µ–Ω–∏–π |

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ —Å–∫–∏–ø-–ª–∏—Å—Ç–æ–≤:**
- ‚úÖ –ü—Ä–æ—Å—Ç–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è (–ø—Ä–æ—â–µ AVL/RB-–¥–µ—Ä–µ–≤—å–µ–≤)
- ‚úÖ –•–æ—Ä–æ—à–∞—è cache-locality
- ‚úÖ –õ–µ–≥–∫–æ –¥–µ–ª–∞—Ç—å –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω—ã–º–∏ (lock-free)
- ‚úÖ –ü—Ä–æ—Å—Ç–∞—è –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å

**–ù–µ–¥–æ—Å—Ç–∞—Ç–∫–∏:**
- ‚ùå –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–Ω—ã–µ –≥–∞—Ä–∞–Ω—Ç–∏–∏ (–Ω–µ –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ)
- ‚ùå –ë–æ–ª—å—à–µ –ø–∞–º—è—Ç–∏, —á–µ–º —É —Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–µ—Ä–µ–≤—å–µ–≤

---

# –°–ª–∏–≤–∞–µ–º—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö {id: "mergeable-structures"}

## –ß—Ç–æ —Ç–∞–∫–æ–µ —Å–ª–∏–≤–∞–µ–º—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã {id: "what-is-mergeable"}

**–°–ª–∏–≤–∞–µ–º–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö (Mergeable Data Structure)** ‚Äî —Å—Ç—Ä—É–∫—Ç—É—Ä–∞, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â–∞—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—É—é –æ–ø–µ—Ä–∞—Ü–∏—é —Å–ª–∏—è–Ω–∏—è –¥–≤—É—Ö —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤.

### –û–ø–µ—Ä–∞—Ü–∏–∏

–ü–æ–º–∏–º–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π (insert, delete, find-min), —Å–ª–∏–≤–∞–µ–º—ã–µ –∫—É—á–∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç:

**Merge (Union):**
```pseudocode
func merge(h1: Heap, h2: Heap) -> Heap:
    # –û–±—ä–µ–¥–∏–Ω–∏—Ç—å –¥–≤–µ –∫—É—á–∏
    return h1.union(h2)
```

**–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ:**
1. **–ê–ª–≥–æ—Ä–∏—Ç–º –î–µ–π–∫—Å—Ç—Ä—ã** —Å –∏–∑–º–µ–Ω—è–µ–º—ã–º–∏ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞–º–∏
2. **–ê–ª–≥–æ—Ä–∏—Ç–º –ü—Ä–∏–º–∞** –¥–ª—è –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –æ—Å—Ç–æ–≤–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞
3. **–°–∏—Å—Ç–µ–º–∞ –Ω–µ–ø–µ—Ä–µ—Å–µ–∫–∞—é—â–∏—Ö—Å—è –º–Ω–æ–∂–µ—Å—Ç–≤** (Disjoint Set Union)
4. **–ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã** ‚Äî —Å–ª–∏—è–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∏–∑ —Ä–∞–∑–Ω—ã—Ö –ø–æ—Ç–æ–∫–æ–≤

---

## –ë–∏–Ω–æ–º–∏–∞–ª—å–Ω—ã–µ –∫—É—á–∏ {id: "binomial-heaps"}

### –ë–∏–Ω–æ–º–∏–∞–ª—å–Ω–æ–µ –¥–µ—Ä–µ–≤–æ

**–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ:** –ë–∏–Ω–æ–º–∏–∞–ª—å–Ω–æ–µ –¥–µ—Ä–µ–≤–æ $B_k$ –ø–æ—Ä—è–¥–∫–∞ $k$ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ:
- $B_0$ ‚Äî –æ–¥–∏–Ω —É–∑–µ–ª
- $B_k$ ‚Äî –¥–≤–∞ –¥–µ—Ä–µ–≤–∞ $B_{k-1}$, –æ–¥–Ω–æ –∫–∞–∫ –ø–æ–¥–¥–µ—Ä–µ–≤–æ –¥—Ä—É–≥–æ–≥–æ

**–°–≤–æ–π—Å—Ç–≤–∞ –±–∏–Ω–æ–º–∏–∞–ª—å–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞** $B_k$:
- –í—ã—Å–æ—Ç–∞: $k$
- –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–∑–ª–æ–≤: $2^k$
- –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–∑–ª–æ–≤ –Ω–∞ –≥–ª—É–±–∏–Ω–µ $d$: $\binom{k}{d}$ (–±–∏–Ω–æ–º–∏–∞–ª—å–Ω—ã–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã)

**–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è:**

```mermaid
graph TB
    subgraph "B‚ÇÄ"
        B0[‚Ä¢]
    end
    
    subgraph "B‚ÇÅ"
        B1_0[‚Ä¢] --> B1_1[‚Ä¢]
    end
    
    subgraph "B‚ÇÇ"
        B2_0[‚Ä¢] --> B2_1[‚Ä¢]
        B2_0 --> B2_2[‚Ä¢]
        B2_2 --> B2_3[‚Ä¢]
    end
    
    subgraph "B‚ÇÉ"
        B3_0[‚Ä¢] --> B3_1[‚Ä¢]
        B3_0 --> B3_2[‚Ä¢]
        B3_0 --> B3_3[‚Ä¢]
        B3_2 --> B3_4[‚Ä¢]
        B3_2 --> B3_5[‚Ä¢]
        B3_3 --> B3_6[‚Ä¢]
        B3_5 --> B3_7[‚Ä¢]
    end
```

### –ë–∏–Ω–æ–º–∏–∞–ª—å–Ω–∞—è –∫—É—á–∞

**–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ:** –ë–∏–Ω–æ–º–∏–∞–ª—å–Ω–∞—è –∫—É—á–∞ ‚Äî —ç—Ç–æ **–Ω–∞–±–æ—Ä –±–∏–Ω–æ–º–∏–∞–ª—å–Ω—ã—Ö –¥–µ—Ä–µ–≤—å–µ–≤**, –≥–¥–µ:
1. –ö–∞–∂–¥–æ–µ –¥–µ—Ä–µ–≤–æ —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è–µ—Ç —Å–≤–æ–π—Å—Ç–≤—É –∫—É—á–∏ (min-heap)
2. –ù–µ –±–æ–ª–µ–µ –æ–¥–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞ –∫–∞–∂–¥–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞

**–°–≤—è–∑—å —Å –¥–≤–æ–∏—á–Ω—ã–º –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ–º:**

–ö—É—á–∞ –∏–∑ $n = 13 = 1101_2$ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Å–æ–¥–µ—Ä–∂–∏—Ç –¥–µ—Ä–µ–≤—å—è:
- $B_3$ (8 —É–∑–ª–æ–≤)
- $B_2$ (4 —É–∑–ª–∞)
- $B_0$ (1 —É–∑–µ–ª)

```
n = 13 = 1101‚ÇÇ
         ||||
         |||‚îî‚îÄ B‚ÇÄ (1 —É–∑–µ–ª)
         ||‚îî‚îÄ‚îÄ 0  (–Ω–µ—Ç B‚ÇÅ)
         |‚îî‚îÄ‚îÄ‚îÄ B‚ÇÇ (4 —É–∑–ª–∞)
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ B‚ÇÉ (8 —É–∑–ª–æ–≤)
```

### –û–ø–µ—Ä–∞—Ü–∏–∏

#### Merge (–°–ª–∏—è–Ω–∏–µ)

**–ê–ª–≥–æ—Ä–∏—Ç–º:** –ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ —Å–ª–æ–∂–µ–Ω–∏—é –¥–≤–æ–∏—á–Ω—ã—Ö —á–∏—Å–µ–ª —Å –ø–µ—Ä–µ–Ω–æ—Å–æ–º

```pseudocode
struct BinomialNode<K>:
    key: K
    degree: int              # –ü–æ—Ä—è–¥–æ–∫ –¥–µ—Ä–µ–≤–∞
    parent: BinomialNode<K>* = null
    child: BinomialNode<K>* = null      # –°—Ç–∞—Ä—à–∏–π —Ä–µ–±—ë–Ω–æ–∫
    sibling: BinomialNode<K>* = null    # –°–ª–µ–¥—É—é—â–∏–π –±—Ä–∞—Ç

class BinomialHeap<K>:
    head: BinomialNode<K>* = null  # –£–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ —Å–ø–∏—Å–æ–∫ –∫–æ—Ä–Ω–µ–π
    
    func merge_trees(h1: BinomialNode<K>*, h2: BinomialNode<K>*) -> BinomialNode<K>*:
        # –û–±—ä–µ–¥–∏–Ω–∏—Ç—å –¥–≤–∞ –¥–µ—Ä–µ–≤–∞ –æ–¥–Ω–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞ - O(1)
        if h1.key > h2.key:
            swap(h1, h2)
        
        # h2 —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —Ä–µ–±—ë–Ω–∫–æ–º h1
        h2.parent = h1
        h2.sibling = h1.child
        h1.child = h2
        h1.degree += 1
        
        return h1
    
    func union(other: BinomialHeap<K>) -> BinomialHeap<K>:
        # –°–ª–∏—è–Ω–∏–µ –¥–≤—É—Ö –∫—É—á - O(log n)
        var merged_head = self._merge_root_lists(self.head, other.head)
        
        if merged_head == null:
            return BinomialHeap<K>()
        
        # –£–ø–æ—Ä—è–¥–æ—á–∏–≤–∞–µ–º –¥–µ—Ä–µ–≤—å—è –ø–æ –ø–æ—Ä—è–¥–∫–∞–º
        var result = BinomialHeap<K>()
        var prev: BinomialNode<K>* = null
        var curr = merged_head
        var next_node = curr.sibling
        
        while next_node != null:
            # –ï—Å–ª–∏ —Ç–µ–∫—É—â–µ–µ –∏ —Å–ª–µ–¥—É—é—â–µ–µ –¥–µ—Ä–µ–≤—å—è —Ä–∞–∑–Ω–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞
            # –∏–ª–∏ –µ—Å—Ç—å —Ç—Ä–∏ –¥–µ—Ä–µ–≤–∞ –ø–æ–¥—Ä—è–¥ –æ–¥–Ω–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞
            if (curr.degree != next_node.degree ||
                (next_node.sibling != null &&
                 next_node.sibling.degree == curr.degree)):
                prev = curr
                curr = next_node
            else:
                # –û–±—ä–µ–¥–∏–Ω—è–µ–º curr –∏ next
                if curr.key <= next_node.key:
                    curr.sibling = next_node.sibling
                    curr = self.merge_trees(curr, next_node)
                else:
                    if prev == null:
                        merged_head = next_node
                    else:
                        prev.sibling = next_node
                    curr = self.merge_trees(next_node, curr)
            
            next_node = curr.sibling
        
        result.head = merged_head
        return result
```

**–ü—Ä–∏–º–µ—Ä —Å–ª–∏—è–Ω–∏—è:**

```
–ö—É—á–∞ 1: B‚ÇÄ(3) ‚Üí B‚ÇÇ(1)
–ö—É—á–∞ 2: B‚ÇÅ(7) ‚Üí B‚ÇÇ(5)

–®–∞–≥ 1: –û–±—ä–µ–¥–∏–Ω—è–µ–º —Å–ø–∏—Å–∫–∏
  B‚ÇÄ(3) ‚Üí B‚ÇÅ(7) ‚Üí B‚ÇÇ(1) ‚Üí B‚ÇÇ(5)

–®–∞–≥ 2: –û–±—ä–µ–¥–∏–Ω—è–µ–º –¥–≤–∞ B‚ÇÇ
  B‚ÇÄ(3) ‚Üí B‚ÇÅ(7) ‚Üí B‚ÇÉ(1)
                  ‚îú‚îÄ B‚ÇÇ(5)
                  ‚îî‚îÄ ...

–†–µ–∑—É–ª—å—Ç–∞—Ç: B‚ÇÄ(3) ‚Üí B‚ÇÅ(7) ‚Üí B‚ÇÉ(1)
```

**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** $O(\log n)$ –≥–¥–µ $n$ ‚Äî –æ–±—â–µ–µ —á–∏—Å–ª–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤

#### Insert

```pseudocode
func insert(key: K) -> void:
    # –í—Å—Ç–∞–≤–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–∞ - O(log n)
    var new_heap = BinomialHeap<K>()
    new_heap.head = new BinomialNode<K>(key)
    self = self.union(new_heap)
```

#### Extract-Min

```pseudocode
func extract_min() -> K:
    # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –º–∏–Ω–∏–º—É–º–∞ - O(log n)
    if self.head == null:
        return null  # –û—à–∏–±–∫–∞: –∫—É—á–∞ –ø—É—Å—Ç–∞
    
    # –ù–∞—Ö–æ–¥–∏–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –∫–æ—Ä–µ–Ω—å
    var min_node = self.head
    var min_prev: BinomialNode<K>* = null
    var prev: BinomialNode<K>* = null
    var curr = self.head
    
    while curr.sibling != null:
        if curr.sibling.key < min_node.key:
            min_node = curr.sibling
            min_prev = curr
        prev = curr
        curr = curr.sibling
    
    # –£–¥–∞–ª—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –∫–æ—Ä–µ–Ω—å
    if min_prev == null:
        self.head = min_node.sibling
    else:
        min_prev.sibling = min_node.sibling
    
    # –°–æ–∑–¥–∞—ë–º –Ω–æ–≤—É—é –∫—É—á—É –∏–∑ –¥–µ—Ç–µ–π –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ —É–∑–ª–∞
    var new_heap = BinomialHeap<K>()
    var child = min_node.child
    while child != null:
        var next_child = child.sibling
        child.sibling = new_heap.head
        child.parent = null
        new_heap.head = child
        child = next_child
    
    # –û–±—ä–µ–¥–∏–Ω—è–µ–º —Å —Ç–µ–∫—É—â–µ–π –∫—É—á–µ–π
    self = self.union(new_heap)
    
    return min_node.key
```

### –¢–∞–±–ª–∏—Ü–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏

| –û–ø–µ—Ä–∞—Ü–∏—è | –°–ª–æ–∂–Ω–æ—Å—Ç—å | –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π |
|----------|-----------|-------------|
| Find-Min | $O(\log n)$ | –ù—É–∂–Ω–æ –ø—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –≤—Å–µ –∫–æ—Ä–Ω–∏ |
| Insert | $O(\log n)$ | –°–ª–∏—è–Ω–∏–µ —Å –æ–¥–Ω–æ—ç–ª–µ–º–µ–Ω—Ç–Ω–æ–π –∫—É—á–µ–π |
| Extract-Min | $O(\log n)$ | –£–¥–∞–ª–µ–Ω–∏–µ –∫–æ—Ä–Ω—è + —Å–ª–∏—è–Ω–∏–µ –¥–µ—Ç–µ–π |
| Merge | $O(\log n)$ | –û—Å–Ω–æ–≤–Ω–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è |
| Decrease-Key | $O(\log n)$ | –ü—Ä–æ—Å–µ–∏–≤–∞–Ω–∏–µ –≤–≤–µ—Ä—Ö |

---

## –§–∏–±–æ–Ω–∞—á—á–∏–µ–≤—ã –∫—É—á–∏ {id: "fibonacci-heaps"}

### –ú–æ—Ç–∏–≤–∞—Ü–∏—è

–ë–∏–Ω–æ–º–∏–∞–ª—å–Ω—ã–µ –∫—É—á–∏ —Ö–æ—Ä–æ—à–∏, –Ω–æ –º–æ–∂–µ–º –ª–∏ –º—ã —Å–¥–µ–ª–∞—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –±—ã—Å—Ç—Ä–µ–µ?

**–ò–¥–µ—è:** –ò—Å–ø–æ–ª—å–∑—É–µ–º **–ª–µ–Ω–∏–≤—ã–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è** ‚Äî –æ—Ç–∫–ª–∞–¥—ã–≤–∞–µ–º —Ä–∞–±–æ—Ç—É –¥–æ –º–æ–º–µ–Ω—Ç–∞, –∫–æ–≥–¥–∞ –æ–Ω–∞ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –Ω—É–∂–Ω–∞.

### –°—Ç—Ä—É–∫—Ç—É—Ä–∞

–§–∏–±–æ–Ω–∞—á—á–∏–µ–≤–∞ –∫—É—á–∞ ‚Äî —ç—Ç–æ **–∫–æ–ª–ª–µ–∫—Ü–∏—è –¥–µ—Ä–µ–≤—å–µ–≤ —Å heap-order**, –Ω–æ **–±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π –Ω–∞ —Ñ–æ—Ä–º—É** –¥–µ—Ä–µ–≤—å–µ–≤.

**–û—Ç–ª–∏—á–∏—è –æ—Ç –±–∏–Ω–æ–º–∏–∞–ª—å–Ω–æ–π –∫—É—á–∏:**
- ‚ùå –ù–µ—Ç —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è –æ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏ –ø–æ—Ä—è–¥–∫–∞
- ‚ùå –î–µ—Ä–µ–≤—å—è –Ω–µ –æ–±—è–∑–∞–Ω—ã –±—ã—Ç—å –±–∏–Ω–æ–º–∏–∞–ª—å–Ω—ã–º–∏
- ‚úÖ –ë–æ–ª–µ–µ –≥–∏–±–∫–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞
- ‚úÖ –õ—É—á—à–∞—è –∞–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å

**–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:**
- –ö–∞–∂–¥—ã–π —É–∑–µ–ª –ø–æ–º–µ—á–µ–Ω, –±—ã–ª –ª–∏ –æ–Ω "marked" (–ø–æ—Ç–µ—Ä—è–ª –ª–∏ –æ–Ω —Ä–µ–±—ë–Ω–∫–∞)
- –£–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç

### –û–ø–µ—Ä–∞—Ü–∏–∏

#### Insert

```pseudocode
func insert(key: K) -> void:
    # –í—Å—Ç–∞–≤–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–∞ - O(1) –∞–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ
    var new_node = new FibNode<K>(key)
    
    if self.min == null:
        self.min = new_node
        new_node.left = new_node
        new_node.right = new_node
    else:
        # –î–æ–±–∞–≤–ª—è–µ–º –≤ –∫–æ—Ä–Ω–µ–≤–æ–π —Å–ø–∏—Å–æ–∫
        self._add_to_root_list(new_node)
        if new_node.key < self.min.key:
            self.min = new_node
    
    self.n += 1
```

**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** $O(1)$ ‚Äî –ø—Ä–æ—Å—Ç–æ –¥–æ–±–∞–≤–ª—è–µ–º –≤ –∫–æ—Ä–Ω–µ–≤–æ–π —Å–ø–∏—Å–æ–∫!

#### Merge

```pseudocode
func union(other: FibonacciHeap<K>) -> FibonacciHeap<K>:
    # –°–ª–∏—è–Ω–∏–µ –∫—É—á - O(1)
    if other.min == null:
        return self
    if self.min == null:
        return other
    
    # –û–±—ä–µ–¥–∏–Ω—è–µ–º –∫–æ—Ä–Ω–µ–≤—ã–µ —Å–ø–∏—Å–∫–∏
    self._concatenate_lists(self.min, other.min)
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –º–∏–Ω–∏–º—É–º
    if other.min.key < self.min.key:
        self.min = other.min
    
    self.n += other.n
    return self
```

**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** $O(1)$ ‚Äî –ø—Ä–æ—Å—Ç–æ –æ–±—ä–µ–¥–∏–Ω—è–µ–º —Å–ø–∏—Å–∫–∏!

#### Extract-Min

```pseudocode
func extract_min() -> K:
    # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –º–∏–Ω–∏–º—É–º–∞ - O(log n) –∞–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ
    var z = self.min
    
    if z != null:
        # –î–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ—Ö –¥–µ—Ç–µ–π –≤ –∫–æ—Ä–Ω–µ–≤–æ–π —Å–ø–∏—Å–æ–∫
        if z.child != null:
            var child = z.child
            loop:
                var next_child = child.right
                self._add_to_root_list(child)
                child.parent = null
                child = next_child
                if child == z.child:
                    break loop
        
        # –£–¥–∞–ª—è–µ–º –º–∏–Ω–∏–º—É–º –∏–∑ –∫–æ—Ä–Ω–µ–≤–æ–≥–æ —Å–ø–∏—Å–∫–∞
        self._remove_from_root_list(z)
        
        if z == z.right:
            self.min = null
        else:
            self.min = z.right
            self._consolidate()  # ‚Üê –ö–ª—é—á–µ–≤–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è!
        
        self.n -= 1
    
    return z.key if z != null else null
```

#### Consolidate (–∫–æ–Ω—Å–æ–ª–∏–¥–∞—Ü–∏—è)

**–¶–µ–ª—å:** –ü—Ä–∏–≤–µ—Å—Ç–∏ –∫—É—á—É –∫ —Å–æ—Å—Ç–æ—è–Ω–∏—é, –≥–¥–µ **–Ω–µ—Ç –¥–≤—É—Ö –¥–µ—Ä–µ–≤—å–µ–≤ –æ–¥–∏–Ω–∞–∫–æ–≤–æ–≥–æ —Ä–∞–Ω–≥–∞**.

```pseudocode
func _consolidate() -> void:
    # –ö–æ–Ω—Å–æ–ª–∏–¥–∞—Ü–∏—è - –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –¥–µ—Ä–µ–≤—å–µ–≤ –æ–¥–∏–Ω–∞–∫–æ–≤–æ–≥–æ —Ä–∞–Ω–≥–∞ - O(log n)
    var max_degree: int = floor(log‚ÇÇ(self.n)) + 2
    var degree_table: vector< FibNode<K>* > = vector(max_degree, null)
    
    # –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –∫–æ—Ä–Ω–∏
    var roots: vector< FibNode<K>* > = vector()
    var curr = self.min
    loop:
        roots.push_back(curr)
        curr = curr.right
        if curr == self.min:
            break
    
    # –û–±—ä–µ–¥–∏–Ω—è–µ–º –¥–µ—Ä–µ–≤—å—è –æ–¥–∏–Ω–∞–∫–æ–≤–æ–≥–æ —Ä–∞–Ω–≥–∞
    for root in roots:
        var degree: int = root.degree
        while degree_table[degree] != null:
            var other = degree_table[degree]
            if root.key > other.key:
                swap(root, other)
            
            # –î–µ–ª–∞–µ–º other —Ä–µ–±—ë–Ω–∫–æ–º root
            self._link(other, root)
            degree_table[degree] = null
            degree += 1
        
        degree_table[degree] = root
    
    # –ù–∞—Ö–æ–¥–∏–º –Ω–æ–≤—ã–π –º–∏–Ω–∏–º—É–º
    self.min = null
    for root in degree_table:
        if root != null:
            if self.min == null || root.key < self.min.key:
                self.min = root

        if root is not None:
            if self.min is None or root.key < self.min.key:
                self.min = root
```

**–ê–º–æ—Ä—Ç–∏–∑–∞—Ü–∏–æ–Ω–Ω—ã–π –∞–Ω–∞–ª–∏–∑:** 
- –ü–æ—Å–ª–µ extract-min –º–æ–∂–µ—Ç –±—ã—Ç—å –¥–æ $O(n)$ –∫–æ—Ä–Ω–µ–π
- Consolidate —É–º–µ–Ω—å—à–∞–µ—Ç –∏—Ö –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–æ $O(\log n)$
- –°—É–º–º–∞—Ä–Ω–∞—è —Ä–∞–±–æ—Ç–∞: $O(\log n)$ –∞–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ

#### Decrease-Key

**–ö–ª—é—á–µ–≤–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è –¥–ª—è –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –î–µ–π–∫—Å—Ç—Ä—ã!**

```pseudocode
func decrease_key(node: FibNode<K>, new_key: K) -> void:
    # –£–º–µ–Ω—å—à–µ–Ω–∏–µ –∫–ª—é—á–∞ - O(1) –∞–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ
    if new_key > node.key:
        return  # –û—à–∏–±–∫–∞: –Ω–æ–≤—ã–π –∫–ª—é—á –±–æ–ª—å—à–µ —Å—Ç–∞—Ä–æ–≥–æ
    
    node.key = new_key
    var parent = node.parent
    
    if parent != null && node.key < parent.key:
        self._cut(node, parent)
        self._cascading_cut(parent)
    
    if node.key < self.min.key:
        self.min = node

func _cut(node: FibNode<K>, parent: FibNode<K>) -> void:
    # –í—ã—Ä–µ–∑–∞—Ç—å —É–∑–µ–ª –∏–∑ —Ä–æ–¥–∏—Ç–µ–ª—è
    # –£–¥–∞–ª—è–µ–º node –∏–∑ —Å–ø–∏—Å–∫–∞ –¥–µ—Ç–µ–π parent
    self._remove_from_child_list(parent, node)
    parent.degree -= 1
    
    # –î–æ–±–∞–≤–ª—è–µ–º node –≤ –∫–æ—Ä–Ω–µ–≤–æ–π —Å–ø–∏—Å–æ–∫
    self._add_to_root_list(node)
    node.parent = null
    node.marked = false

func _cascading_cut(node: FibNode<K>) -> void:
    # –ö–∞—Å–∫–∞–¥–Ω–æ–µ –≤—ã—Ä–µ–∑–∞–Ω–∏–µ - –≤–∞–∂–Ω–æ –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏—è O(1) —Å—Ä–µ–¥–Ω–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏!
    var parent = node.parent
    if parent != null:
        if !node.marked:
            node.marked = true
        else:
            self._cut(node, parent)
            self._cascading_cut(parent)
```

**–ò–¥–µ—è cascading cut:** –ï—Å–ª–∏ —É–∑–µ–ª —Ç–µ—Ä—è–µ—Ç –≤—Ç–æ—Ä–æ–≥–æ —Ä–µ–±—ë–Ω–∫–∞, –≤—ã—Ä–µ–∑–∞–µ–º –µ–≥–æ —Ç–æ–∂–µ (–¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏—è –º–∞–ª–æ–π –≤—ã—Å–æ—Ç—ã –¥–µ—Ä–µ–≤—å–µ–≤).

### –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –∞–Ω–∞–ª–∏–∑–∞

**–ü–æ—Ç–µ–Ω—Ü–∏–∞–ª –∫—É—á–∏:**

$$\Phi(H) = t(H) + 2 \cdot m(H)$$

–≥–¥–µ:
- $t(H)$ ‚Äî —á–∏—Å–ª–æ –¥–µ—Ä–µ–≤—å–µ–≤ –≤ –∫–æ—Ä–Ω–µ–≤–æ–º —Å–ø–∏—Å–∫–µ
- $m(H)$ ‚Äî —á–∏—Å–ª–æ –ø–æ–º–µ—á–µ–Ω–Ω—ã—Ö —É–∑–ª–æ–≤

**–ê–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å:**

$$\hat{c_i} = c_i + \Phi(H_i) - \Phi(H_{i-1})$$

**–î–ª—è decrease-key:**
- –†–µ–∞–ª—å–Ω–∞—è —Ä–∞–±–æ—Ç–∞: $O(c)$ –≥–¥–µ $c$ ‚Äî —á–∏—Å–ª–æ –∫–∞—Å–∫–∞–¥–Ω—ã—Ö –≤—ã—Ä–µ–∑–∞–Ω–∏–π
- –ò–∑–º–µ–Ω–µ–Ω–∏–µ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª–∞: $-c + 2$ (—É–±—Ä–∞–ª–∏ $c$ –º–µ—Ç–æ–∫, –¥–æ–±–∞–≤–∏–ª–∏ $\leq 1$ –¥–µ—Ä–µ–≤–æ)
- –ê–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å: $O(c) + (-c + 2) = O(1)$

### –¢–∞–±–ª–∏—Ü–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏

| –û–ø–µ—Ä–∞—Ü–∏—è | –ê–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è | –•—É–¥—à–∏–π —Å–ª—É—á–∞–π |
|----------|-----------------|---------------|
| Find-Min | $O(1)$ | $O(1)$ |
| Insert | $O(1)$ | $O(1)$ |
| Merge | $O(1)$ | $O(1)$ |
| Extract-Min | $O(\log n)$ | $O(n)$ |
| Decrease-Key | $O(1)$ | $O(n)$ |
| Delete | $O(\log n)$ | $O(n)$ |

---

## Leftist heaps {id: "leftist-heaps"}

### –ú–æ—Ç–∏–≤–∞—Ü–∏—è

**–ü—Ä–æ–±–ª–µ–º–∞:** –û–±—ã—á–Ω–∞—è –¥–≤–æ–∏—á–Ω–∞—è –∫—É—á–∞ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ —Å–ª–∏—è–Ω–∏–µ.

**–†–µ—à–µ–Ω–∏–µ:** Leftist heap ‚Äî –∫—É—á–∞ —Å –æ—Å–æ–±—ã–º —Å–≤–æ–π—Å—Ç–≤–æ–º, –ø–æ–∑–≤–æ–ª—è—é—â–∏–º –±—ã—Å—Ç—Ä–æ —Å–ª–∏–≤–∞—Ç—å.

### –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ

**–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ –ø—Ä–∞–≤–æ–≥–æ –∫—Ä–∞—è (null path length, npl):**

$$
\text{npl}(x) = \begin{cases}
0 & \text{–µ—Å–ª–∏ } x \text{ ‚Äî –ª–∏—Å—Ç} \\
1 + \min(\text{npl}(\text{left}(x)), \text{npl}(\text{right}(x))) & \text{–∏–Ω–∞—á–µ}
\end{cases}
$$

**Leftist —Å–≤–æ–π—Å—Ç–≤–æ:** –î–ª—è –∫–∞–∂–¥–æ–≥–æ —É–∑–ª–∞:

$$\text{npl}(\text{left}(x)) \geq \text{npl}(\text{right}(x))$$

–≠—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ **–ø—Ä–∞–≤—ã–π –ø—É—Ç—å –≤—Å–µ–≥–¥–∞ –∫–æ—Ä–æ—á–µ –∏–ª–∏ —Ä–∞–≤–µ–Ω –ª–µ–≤–æ–º—É**.

### –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è

```mermaid
graph TB
    N1["3<br>npl=2"] --> N2["8<br>npl=1"]
    N1 --> N3["10<br>npl=1"]
    N2 --> N4["17<br>npl=0"]
    N2 --> N5["21<br>npl=0"]
    N3 --> N6["14<br>npl=0"]
    N3 --> N7["23<br>npl=0"]
    
    style N1 fill:yellow
    style N2 fill:green
    style N3 fill:cyan
```

### –°–ª–∏—è–Ω–∏–µ

**–ê–ª–≥–æ—Ä–∏—Ç–º:**
1. –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º –∫–æ—Ä–Ω–∏, –º–µ–Ω—å—à–∏–π —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –Ω–æ–≤—ã–º –∫–æ—Ä–Ω–µ–º
2. –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ —Å–ª–∏–≤–∞–µ–º –ø—Ä–∞–≤–æ–µ –ø–æ–¥–¥–µ—Ä–µ–≤–æ —Å –¥—Ä—É–≥–æ–π –∫—É—á–µ–π
3. –ï—Å–ª–∏ leftist —Å–≤–æ–π—Å—Ç–≤–æ –Ω–∞—Ä—É—à–µ–Ω–æ, –º–µ–Ω—è–µ–º –º–µ—Å—Ç–∞–º–∏ –¥–µ—Ç–µ–π

```pseudocode
struct LeftistNode<K>:
    key: K
    left: LeftistNode<K>* = null
    right: LeftistNode<K>* = null
    npl: int = 0                # null path length

class LeftistHeap<K>:
    root: LeftistNode<K>* = null
    
    func merge(other: LeftistHeap<K>) -> LeftistHeap<K>:
        # –°–ª–∏—è–Ω–∏–µ –¥–≤—É—Ö –∫—É—á - O(log n)
        self.root = self._merge_nodes(self.root, other.root)
        return self
    
    func _merge_nodes(h1: LeftistNode<K>*, h2: LeftistNode<K>*) -> LeftistNode<K>*:
        # –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ–µ —Å–ª–∏—è–Ω–∏–µ —É–∑–ª–æ–≤
        if h1 == null:
            return h2
        if h2 == null:
            return h1
        
        # –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ h1.key <= h2.key
        if h1.key > h2.key:
            swap(h1, h2)
        
        # –°–ª–∏–≤–∞–µ–º h2 —Å –ø—Ä–∞–≤—ã–º –ø–æ–¥–¥–µ—Ä–µ–≤–æ–º h1
        h1.right = self._merge_nodes(h1.right, h2)
        
        # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º leftist —Å–≤–æ–π—Å—Ç–≤–æ
        if h1.left == null:
            h1.left = h1.right
            h1.right = null
        else:
            var left_npl: int = (h1.left != null) ? h1.left.npl : -1
            var right_npl: int = (h1.right != null) ? h1.right.npl : -1
            
            if left_npl < right_npl:
                swap(h1.left, h1.right)
        
        # –û–±–Ω–æ–≤–ª—è–µ–º npl
        h1.npl = ((h1.right != null) ? h1.right.npl : -1) + 1
        
        return h1
    
    func insert(key: K) -> void:
        # –í—Å—Ç–∞–≤–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–∞ - O(log n)
        var new_node = new LeftistNode<K>(key)
        self.root = self._merge_nodes(self.root, new_node)
    
    func extract_min() -> K:
        # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –º–∏–Ω–∏–º—É–º–∞ - O(log n)
        if self.root == null:
            return null  # –û—à–∏–±–∫–∞: –∫—É—á–∞ –ø—É—Å—Ç–∞
        
        var min_key = self.root.key
        self.root = self._merge_nodes(self.root.left, self.root.right)
        return min_key
```

### –ü–æ—á–µ–º—É —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç?

**–õ–µ–º–º–∞:** Leftist heap –∏–∑ $n$ —É–∑–ª–æ–≤ –∏–º–µ–µ—Ç –¥–ª–∏–Ω—É –ø—Ä–∞–≤–æ–≥–æ –ø—É—Ç–∏ $O(\log n)$.

**–î–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ:** 
- –ü—É—Å—Ç—å –¥–ª–∏–Ω–∞ –ø—Ä–∞–≤–æ–≥–æ –ø—É—Ç–∏ = $r$
- –ö–∞–∂–¥—ã–π —É–∑–µ–ª –Ω–∞ –ø—Ä–∞–≤–æ–º –ø—É—Ç–∏ –∏–º–µ–µ—Ç $\text{npl} \geq 0, 1, 2, \ldots, r-1$
- –ü–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—é npl, –ø–æ–¥ –∫–∞–∂–¥—ã–º —Ç–∞–∫–∏–º —É–∑–ª–æ–º –º–∏–Ω–∏–º—É–º $2^i$ —É–∑–ª–æ–≤
- –ò—Ç–æ–≥–æ: $n \geq 1 + 2 + 4 + \ldots + 2^{r-1} = 2^r - 1$
- –°–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ: $r \leq \log(n+1)$

### –°–ª–æ–∂–Ω–æ—Å—Ç—å –æ–ø–µ—Ä–∞—Ü–∏–π

| –û–ø–µ—Ä–∞—Ü–∏—è | –°–ª–æ–∂–Ω–æ—Å—Ç—å |
|----------|-----------|
| Find-Min | $O(1)$ |
| Insert | $O(\log n)$ |
| Extract-Min | $O(\log n)$ |
| Merge | $O(\log n)$ |

---

# –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–æ–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ {id: "practical-applications"}

## –ì–¥–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

### 1. –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ

**Haskell, Clojure, Scala:**
```haskell
-- Haskell: –≤—Å–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
let list1 = [1, 2, 3]
    list2 = 4 : list1  -- [4, 1, 2, 3]
    list3 = 0 : list1  -- [0, 1, 2, 3]
-- list1 –Ω–µ –∏–∑–º–µ–Ω–∏–ª—Å—è!
```

### 2. –°–∏—Å—Ç–µ–º—ã –∫–æ–Ω—Ç—Ä–æ–ª—è –≤–µ—Ä—Å–∏–π

**Git –≤–Ω—É—Ç—Ä–µ–Ω–Ω–æ—Å—Ç–∏:**
- Commits ‚Äî –≤–µ—Ä—Å–∏–∏ —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã
- Trees ‚Äî –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ã–µ –¥–µ—Ä–µ–≤—å—è –∫–∞—Ç–∞–ª–æ–≥–æ–≤
- Structural sharing ‚Äî —Ñ–∞–π–ª—ã –Ω–µ –∫–æ–ø–∏—Ä—É—é—Ç—Å—è, –µ—Å–ª–∏ –Ω–µ –∏–∑–º–µ–Ω–∏–ª–∏—Å—å

### 3. –ë–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö

**MVCC (Multi-Version Concurrency Control):**
```sql
-- PostgreSQL
BEGIN;
SELECT * FROM users WHERE id = 1;  -- –í–∏–¥–∏–º –≤–µ—Ä—Å–∏—é –Ω–∞ –º–æ–º–µ–Ω—Ç –Ω–∞—á–∞–ª–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
-- –î—Ä—É–≥–∞—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –∏–∑–º–µ–Ω—è–µ—Ç —Ç—É –∂–µ —Å—Ç—Ä–æ–∫—É
-- –ú—ã –≤—Å—ë —Ä–∞–≤–Ω–æ –≤–∏–¥–∏–º —Å—Ç–∞—Ä—É—é –≤–µ—Ä—Å–∏—é!
COMMIT;
```

### 4. –†–µ–¥–∞–∫—Ç–æ—Ä—ã –∫–æ–¥–∞

**Undo/Redo —Å—Ç–µ–∫:**
```pseudocode
class Editor:
    versions: vector< PersistentText > = vector()
    current: int = 0
    
    func init() -> void:
        versions.push_back(PersistentText(""))
        current = 0
    
    func insert(pos: int, char: char) -> void:
        var new_text = versions[current].insert(pos, char)
        versions = versions[0..current] + [new_text]
        current += 1
    
    func undo() -> void:
        if current > 0:
            current -= 1
    
    func redo() -> void:
        if current < versions.size() - 1:
            current += 1
```

## –ì–¥–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —Å–∫–∏–ø-–ª–∏—Å—Ç—ã

### 1. Redis

**Sorted Sets:**
```bash
ZADD leaderboard 100 "player1"
ZADD leaderboard 200 "player2"
ZRANGE leaderboard 0 -1 WITHSCORES
```

–í–Ω—É—Ç—Ä–∏: —Å–∫–∏–ø-–ª–∏—Å—Ç + —Ö–µ—à-—Ç–∞–±–ª–∏—Ü–∞

### 2. LevelDB / RocksDB

**MemTable:** –°–∫–∏–ø-–ª–∏—Å—Ç –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –Ω–µ–¥–∞–≤–Ω–∏—Ö –∑–∞–ø–∏—Å–µ–π –≤ –ø–∞–º—è—Ç–∏

### 3. Lucene / Elasticsearch

**Term Dictionary:** –°–∫–∏–ø-–ª–∏—Å—Ç—ã –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞ —Ç–µ—Ä–º–∏–Ω–æ–≤

### 4. Concurrent Skip Lists

**Java ConcurrentSkipListMap:**
```pseudocode
class ConcurrentSkipListMap<K, V>:
    func put(key: K, value: V) -> V:
        # –í—Å—Ç–∞–≤–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –ø–æ—Ç–æ–∫–æ–±–µ–∑–æ–ø–∞—Å–Ω–æ
        return self._insert_lock_free(key, value)
    
    func get(key: K) -> V | null:
        # –ü–æ–ª—É—á–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –ø–æ—Ç–æ–∫–æ–±–µ–∑–æ–ø–∞—Å–Ω–æ
        return self._search(key)

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
var map = ConcurrentSkipListMap<int, string>()
map.put(1, "one")
map.put(2, "two")
# –ü–æ—Ç–æ–∫–æ–±–µ–∑–æ–ø–∞—Å–Ω–æ –±–µ–∑ —è–≤–Ω—ã—Ö lock-–æ–≤!
```

## –ì–¥–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —Å–ª–∏–≤–∞–µ–º—ã–µ –∫—É—á–∏

### 1. –ê–ª–≥–æ—Ä–∏—Ç–º –î–µ–π–∫—Å—Ç—Ä—ã

**–° –§–∏–±–æ–Ω–∞—á—á–∏–µ–≤–æ–π –∫—É—á–µ–π:**
```pseudocode
func dijkstra_fibonacci(graph: Graph, start: Vertex) -> map<Vertex, int>:
    var heap = FibonacciHeap<int>()
    var dist: map<Vertex, int> = map()  # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ –∫–∞–∫ ‚àû
    dist[start] = 0
    var nodes: map<Vertex, FibNode> = map()
    
    for v in graph.vertices():
        if v == start:
            nodes[v] = heap.insert(0)
        else:
            nodes[v] = heap.insert(‚àû)
    
    while !heap.is_empty():
        var (d, u) = heap.extract_min()
        for (v, weight) in graph.adj[u]:
            if dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
                heap.decrease_key(nodes[v], dist[v])  # ‚Üê O(1) –∞–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ!
    
    return dist
```

**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** $O(E + V \log V)$ ‚Äî –ª—É—á—à–µ —á–µ–º —Å –æ–±—ã—á–Ω–æ–π –∫—É—á–µ–π!

### 2. –ê–ª–≥–æ—Ä–∏—Ç–º –ü—Ä–∏–º–∞

**–ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –æ—Å—Ç–æ–≤–Ω–æ–µ –¥–µ—Ä–µ–≤–æ:**
```pseudocode
func prim_fibonacci(graph: Graph) -> set< tuple<Vertex, Vertex, int> >:
    var heap = FibonacciHeap< tuple<int, pair<Vertex, Vertex> > >()
    var mst: set< tuple<Vertex, Vertex, int> > = set()
    var visited: set<Vertex> = set()
    
    # –ù–∞—á–∏–Ω–∞–µ–º —Å –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ–π –≤–µ—Ä—à–∏–Ω—ã
    var start = graph.vertices()[0]
    heap.insert((0, pair(null, start)))
    
    while !heap.is_empty():
        var (weight, (u, v)) = heap.extract_min()
        
        if v in visited:
            continue
        
        visited.insert(v)
        if u != null:
            mst.insert((u, v, weight))
        
        for (neighbor, edge_weight) in graph.adj[v]:
            if neighbor not in visited:
                heap.insert((edge_weight, pair(v, neighbor)))
    
    return mst
```

### 3. Disjoint Set Union (DSU)

**–°–ª–∏—è–Ω–∏–µ –º–Ω–æ–∂–µ—Å—Ç–≤:**
```pseudocode
class DSU:
    heaps: map<any, LeftistHeap>
    
    func __init__():
        self.heaps = map()
    
    func make_set(x: any) -> void:
        self.heaps[x] = new LeftistHeap()
        self.heaps[x].insert(pair(0, x))
    
    func union(x: any, y: any) -> void:
        var heap_x = self.heaps[x]
        var heap_y = self.heaps[y]
        var merged = heap_x.merge(heap_y)
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –≤—Å–µ –≤–µ—Ä—à–∏–Ω—ã
        for v in merged:
            self.heaps[v] = merged
    
    func find(x: any) -> any:
        return self.heaps[x].find_min()
```

---

# –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ —Å–æ–≤–µ—Ç—ã –∏ —Ç–∏–ø–∏—á–Ω—ã–µ –æ—à–∏–±–∫–∏ {id: "practical-tips"}

## –ü–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

### –°–æ–≤–µ—Ç—ã –ø–æ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏

1. **Structural Sharing:** –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å—Ç–∞—Ä—ã–µ —É–∑–ª—ã. –ö–æ–ø–∏—Ä—É–π—Ç–µ —Ç–æ–ª—å–∫–æ –ø—É—Ç—å –æ—Ç –∫–æ—Ä–Ω—è –¥–æ –∏–∑–º–µ–Ω—ë–Ω–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞.
   - Good: Path copying –≤ –º–∞—Å—Å–∏–≤–µ ‚Äì $O(\log n)$ –Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—é
   - Bad: –ü–æ–ª–Ω–æ–µ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ ‚Äì $O(n)$ –Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—é

2. **–í–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ:** –•—Ä–∞–Ω–∏—Ç–µ —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –∫–æ—Ä–µ–Ω—å –∫–∞–∂–¥–æ–π –≤–µ—Ä—Å–∏–∏, –∞ –Ω–µ —Å–∞–º –≥—Ä–∞—Ñ.
   ```pseudocode
   versions: vector<RootNode> = []
   func snapshot() -> void:
       versions.push_back(current_root)
   func restore(version: int) -> void:
       current_root = versions[version]
   ```

3. **–õ–µ–Ω–∏–≤—ã–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è:** –û—Ç–ª–æ–∂–∏—Ç–µ –¥–æ—Ä–æ–≥–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ (–≤—Ä–æ–¥–µ –±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∫–∏) –¥–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏.

### –¢–∏–ø–∏—á–Ω—ã–µ –æ—à–∏–±–∫–∏

‚ùå **–û—à–∏–±–∫–∞ 1:** –ú—É—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç–∞—Ä—ã—Ö –≤–µ—Ä—Å–∏–π –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏.
```pseudocode
# –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û:
func update_v1(node: Node, value: T) -> void:
    node.value = value  # –ú—É—Ç–∏—Ä—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —É–∑–µ–ª!
```

‚úÖ **–ü—Ä–∞–≤–∏–ª—å–Ω–æ:**
```pseudocode
# –ü–†–ê–í–ò–õ–¨–ù–û:
func update_v1(node: Node, value: T) -> Node:
    return new Node(value, node.left, node.right)  # –ù–æ–≤—ã–π —É–∑–µ–ª
```

‚ùå **–û—à–∏–±–∫–∞ 2:** –ó–∞–±—ã–≤–∞—Ç—å –ø—Ä–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–Ω–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏.
```pseudocode
# –ï—Å–ª–∏ —É–¥–∞–ª—è–µ–º —É–∑–µ–ª ‚Äî –µ–≥–æ —Ä–æ–¥–∏—Ç–µ–ª—å –≤—Å—ë —Ä–∞–≤–Ω–æ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Å—Ç–∞—Ä—ã—Ö –¥–µ—Ç–µ–π
# –ù—É–∂–Ω–æ —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤—Å—é —Ü–µ–ø–æ—á–∫—É –¥–æ –∫–æ—Ä–Ω—è
```

‚úÖ **–ü—Ä–∞–≤–∏–ª—å–Ω–æ:** –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ Path Copying –¥–ª—è –ª—é–±–æ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è.

---

## –°–∫–∏–ø-–ª–∏—Å—Ç—ã

### –°–æ–≤–µ—Ç—ã –ø–æ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏

1. **–í—ã–±–æ—Ä p (–≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å):** 
   - $p = 0.5$ ‚Äì –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ –ø–æ —Ç–µ–æ—Ä–∏–∏
   - –ù–∞ –ø—Ä–∞–∫—Ç–∏–∫–µ $p \in [0.25, 0.75]$ —Ä–∞–±–æ—Ç–∞–µ—Ç —Ö–æ—Ä–æ—à–æ
   - –î–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ –∫–ª—é—á–∞–º —Å—Ç—Ä–æ–∫: $p = 1/e \approx 0.368$ –¥–∞—ë—Ç –º–µ–Ω—å—à–µ –ø–∞–º—è—Ç–∏

2. **Max Level:**
   ```pseudocode
   max_level = ceil(log(n) / log(1/p))
   # –î–ª—è p=0.5 –∏ n=10^6: max_level ‚âà 20 (–Ω–µ 16!)
   ```

3. **Seed –¥–ª—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º–æ—Å—Ç–∏:**
   ```pseudocode
   func set_seed(seed: int64) -> void:
       random.seed(seed)
       # –¢–µ–ø–µ—Ä—å —Å–ª—É—á–∞–π–Ω—ã–µ —á–∏—Å–ª–∞ –±—É–¥—É—Ç –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º–∏ –ø—Ä–∏ –∫–∞–∂–¥–æ–º –∑–∞–ø—É—Å–∫–µ
   ```

### –¢–∏–ø–∏—á–Ω—ã–µ –æ—à–∏–±–∫–∏

‚ùå **–û—à–∏–±–∫–∞ 1:** –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —É—Ä–æ–≤–Ω—è.
```pseudocode
# –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û:
func random_level() -> int:
    return random.randint(1, max_level)  # –†–∞–≤–Ω–æ–º–µ—Ä–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ!
```

‚úÖ **–ü—Ä–∞–≤–∏–ª—å–Ω–æ:**
```pseudocode
# –ü–†–ê–í–ò–õ–¨–ù–û:
func random_level() -> int:
    level = 1
    while random.random() < p && level < max_level:
        level += 1
    return level
```

‚ùå **–û—à–∏–±–∫–∞ 2:** –ó–∞–±—ã—Ç—å –æ–±–Ω–æ–≤–∏—Ç—å `level` —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –ø—Ä–∏ –≤—Å—Ç–∞–≤–∫–µ —É–∑–ª–∞ —Å –±–æ–ª—å—à–æ–π –≤—ã—Å–æ—Ç–æ–π.
```pseudocode
# –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û:
func insert(key: K, value: V) -> void:
    new_level = random_level()
    # –ó–∞–±—ã–ª–∏: if new_level > self.level: self.level = new_level
```

‚úÖ **–ü—Ä–∞–≤–∏–ª—å–Ω–æ:** –û–±–Ω–æ–≤–ª—è–π—Ç–µ `self.level` –∏ —Å—Å—ã–ª–∫–∏ `header` –ø—Ä–∏ –∫–∞–∂–¥–æ–π –≤—Å—Ç–∞–≤–∫–µ —Å –Ω–æ–≤—ã–º max-—É—Ä–æ–≤–Ω–µ–º.

---

## –°–ª–∏–≤–∞–µ–º—ã–µ –∫—É—á–∏

### –°–æ–≤–µ—Ç—ã –ø–æ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏

1. **–í—ã–±–æ—Ä –º–µ–∂–¥—É —Ç–∏–ø–∞–º–∏:**
   - **–ë–∏–Ω–æ–º–∏–∞–ª—å–Ω–∞—è –∫—É—á–∞:** Predictable, —Ö–æ—Ä–æ—à–æ –¥–ª—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –Ω–∞ –Ω–∏–∑–∫–æ—É—Ä–æ–≤–Ω–µ–≤—ã—Ö —è–∑—ã–∫–∞—Ö
   - **–§–∏–±–æ–Ω–∞—á—á–∏–µ–≤–∞ –∫—É—á–∞:** –õ—É—á—à–µ –¥–ª—è Dijkstra, –Ω–æ overhead –Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤—ã—à–µ
   - **Leftist heap:** –ü—Ä–æ—Å—Ç–∞—è –≤ –∫–æ–¥–µ, –±–ª–∏–∑–∫–∞ –∫ binary heap –ø–æ —Å–∫–æ—Ä–æ—Å—Ç–∏

2. **Merge –≤–º–µ—Å—Ç–æ insert:**
   ```pseudocode
   # –î–ª—è –±–æ–ª—å—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö: —Å–æ–∑–¥–∞—Ç—å –¥–≤–µ –∫—É—á–∏, –ø–æ—Ç–æ–º merge
   # –≠—Ç–æ —á–∞—Å—Ç–æ –±—ã—Å—Ç—Ä–µ–µ, —á–µ–º N —Ä–∞–∑ –≤—ã–∑–≤–∞—Ç—å insert
   ```

3. **–ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –∞–Ω–∞–ª–∏–∑–∞:**
   –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª–∞ –¥–ª—è –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–∞ –∞–º–æ—Ä—Ç–∏–∑–∞—Ü–∏–æ–Ω–Ω–æ–π —Å–ª–æ–∂–Ω–æ—Å—Ç–∏:
   $$\Phi(H) = t(H) + 2m(H)$$
   –≥–¥–µ $t$ ‚Äì —á–∏—Å–ª–æ –¥–µ—Ä–µ–≤—å–µ–≤, $m$ ‚Äì —á–∏—Å–ª–æ –ø–æ–º–µ—á–µ–Ω–Ω—ã—Ö —É–∑–ª–æ–≤.

### –¢–∏–ø–∏—á–Ω—ã–µ –æ—à–∏–±–∫–∏

‚ùå **–û—à–∏–±–∫–∞ 1:** –ó–∞–±—ã—Ç—å –æ–±–Ω–æ–≤–∏—Ç—å —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –º–∏–Ω–∏–º—É–º –ø–æ—Å–ª–µ —Å–ª–∏—è–Ω–∏—è.
```pseudocode
# –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û:
func merge(h1: FibHeap, h2: FibHeap) -> FibHeap:
    h1.root_list.concat(h2.root_list)
    # –ó–∞–±—ã–ª–∏: if h2.min.key < h1.min.key: h1.min = h2.min
```

‚ùå **–û—à–∏–±–∫–∞ 2:** –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å cascading cut –≤ –§–∏–±–æ–Ω–∞—á—á–∏–µ–≤–æ–π –∫—É—á–µ.
```pseudocode
# –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û ‚Äì –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ü–∏–∫–ª:
func cascading_cut(node: Node) -> void:
    parent = node.parent
    if parent != null:
        cut(node, parent)
        cascading_cut(parent)  # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å marked –ø–µ—Ä–µ–¥ —Ä–µ–∫—É—Ä—Å–∏–µ–π!
```

‚úÖ **–ü—Ä–∞–≤–∏–ª—å–Ω–æ:**
```pseudocode
func cascading_cut(node: Node) -> void:
    parent = node.parent
    if parent != null:
        if !node.marked:
            node.marked = true
        else:
            cut(node, parent)
            cascading_cut(parent)
```

---

# –ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞–∫—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É {id: "choosing-structures"}

## –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ã—Ö –ø–æ–¥—Ö–æ–¥–æ–≤

| –°—Ü–µ–Ω–∞—Ä–∏–π | –õ—É—á—à–∏–π –≤—ã–±–æ—Ä | –ü–æ—á–µ–º—É |
|----------|-------------|-------|
| Undo/Redo –≤ —Ä–µ–¥–∞–∫—Ç–æ—Ä–µ | –ü–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–∞—è –æ—á–µ—Ä–µ–¥—å –Ω–∞ –¥–≤—É—Ö —Å—Ç–µ–∫–∞—Ö | O(1) –æ–ø–µ—Ä–∞—Ü–∏–∏, –ø—Ä–æ—Å—Ç–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è |
| Git-like —Å–∏—Å—Ç–µ–º–∞ –≤–µ—Ä—Å–∏–π | Path Copying –Ω–∞ –¥–µ—Ä–µ–≤—å—è—Ö | –≠–∫–æ–Ω–æ–º–∏—Ç –ø–∞–º—è—Ç—å —á–µ—Ä–µ–∑ structural sharing |
| –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π —è–∑—ã–∫ (Haskell) | –ò–º–º—É—Ç–∞–±–µ–ª—å–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é | –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å + –ø—Ä–æ—Å—Ç–æ—Ç–∞ |
| Big Data processing (MapReduce) | –°–Ω–∏–º–∫–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è (snapshots) | –î–µ—à—ë–≤–æ–µ —Å–ª–∏—è–Ω–∏–µ –≤–µ—Ä—Å–∏–π |

## –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø–æ–∏—Å–∫–∞ –≤ —É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä–∞—Ö

| –°—Ç—Ä—É–∫—Ç—É—Ä–∞ | Insert | Search | Delete | Space | –†–µ–∞–ª–∏–∑–∞—Ü–∏—è | Cache Friendly |
|-----------|--------|--------|--------|-------|-----------|-----------------|
| Skip List | $O(\log n)$ exp. | $O(\log n)$ exp. | $O(\log n)$ exp. | $O(n)$ | ‚≠ê‚≠ê‚≠ê | ‚úÖ |
| AVL Tree | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | $O(n)$ | ‚≠ê‚≠ê | ‚ùå –ü–ª–æ—Ö–æ |
| Red-Black Tree | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | $O(n)$ | ‚≠ê‚≠ê | ‚ùå –ü–ª–æ—Ö–æ |
| B-Tree | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | $O(n)$ | ‚≠ê | ‚úÖ –û—Ç–ª–∏—á–Ω–æ |

**–í—ã–≤–æ–¥:** –î–ª—è in-memory —Å—Ç—Ä—É–∫—Ç—É—Ä ‚Äî Skip List. –î–ª—è –¥–∏—Å–∫–∞ ‚Äî B-Tree. –î–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã ‚Äî Skip List.

## –°—Ä–∞–≤–Ω–µ–Ω–∏–µ priority queues

| –°—Ç—Ä—É–∫—Ç—É—Ä–∞ | Extract-Min | Insert | Merge | Decrease-Key | –õ—É—á—à–µ –≤—Å–µ–≥–æ |
|-----------|------------|--------|-------|--------------|-----------|
| Binary Heap | $O(\log n)$ | $O(\log n)$ | $O(n)$ | $O(\log n)$ | –ü—Ä–æ—Å—Ç–æ—Ç–∞ |
| Binomial Heap | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | Merge –æ–ø–µ—Ä–∞—Ü–∏–∏ |
| Fibonacci Heap | $O(\log n)$ amort. | $O(1)$ amort. | $O(1)$ | $O(1)$ amort. | Dijkstra |
| Leftist Heap | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | –ü—Ä–æ—Å—Ç–æ—Ç–∞ + merge |

**–ü—Ä–∞–≤–∏–ª–æ –±–æ–ª—å—à–æ–≥–æ –ø–∞–ª—å—Ü–∞:**
- –ù—É–∂–µ–Ω merge —á–∞—Å—Ç–æ? ‚Üí Binomial –∏–ª–∏ Leftist heap
- –ù—É–∂–µ–Ω decrease-key —á–∞—Å—Ç–æ? ‚Üí Fibonacci heap
- –ù—É–∂–Ω–∞ –ø—Ä–æ—Å—Ç–æ—Ç–∞? ‚Üí Binary heap –∏–ª–∏ Leftist heap

---

# –ó–∞–¥–∞—á–∏ –¥–ª—è –ø—Ä–∞–∫—Ç–∏–∫–∏ {id: "practice-problems"}

## –õ–µ–≥–∫–æ

### 1. –†–µ–∞–ª–∏–∑—É–π—Ç–µ –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ã–π —Å—Ç–µ–∫
**–ó–∞–¥–∞—á–∞:** –†–µ–∞–ª–∏–∑—É–π—Ç–µ —Å—Ç–µ–∫ —Å –æ–ø–µ—Ä–∞—Ü–∏—è–º–∏ push, pop, peek, –≥–¥–µ –∫–∞–∂–¥–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –Ω–æ–≤—É—é –≤–µ—Ä—Å–∏—é —Å—Ç–µ–∫–∞.

**–†–µ—à–µ–Ω–∏–µ (–Ω–∞–º–µ–∫):**
```pseudocode
class PersistentStack<T>:
    head: Node<T> | null
    
    func push(value: T) -> PersistentStack<T>:
        return new PersistentStack<T>(new Node(value, self.head))
    
    # O(1) –Ω–∞ –∫–∞–∂–¥—É—é –æ–ø–µ—Ä–∞—Ü–∏—é –±–ª–∞–≥–æ–¥–∞—Ä—è linked list
```

**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** $O(1)$ push/pop, $O(n)$ –ø–∞–º—è—Ç—å –Ω–∞ –≤—Å–µ—Ö –≤–µ—Ä—Å–∏—è—Ö.

### 2. –ù–∞–π–¥–∏—Ç–µ k-–π —ç–ª–µ–º–µ–Ω—Ç –≤ —Å–∫–∏–ø-–ª–∏—Å—Ç–µ
**–ó–∞–¥–∞—á–∞:** –ú–æ–¥–∏—Ñ–∏—Ü–∏—Ä—É–π—Ç–µ —Å–∫–∏–ø-–ª–∏—Å—Ç —Ç–∞–∫, —á—Ç–æ–±—ã –º–æ–∂–Ω–æ –±—ã–ª–æ –Ω–∞–π—Ç–∏ k-–π –Ω–∞–∏–º–µ–Ω—å—à–∏–π —ç–ª–µ–º–µ–Ω—Ç –∑–∞ $O(\log n)$.

**–ü–æ–¥—Å–∫–∞–∑–∫–∞:** –î–æ–±–∞–≤—å—Ç–µ –≤ –∫–∞–∂–¥—ã–π —É–∑–µ–ª –ø–æ–ª–µ `count` ‚Äì —á–∏—Å–ª–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤, –Ω–∞ –∫–æ—Ç–æ—Ä—ã–µ –æ–Ω "–ø—Ä—ã–≥–∞–µ—Ç".

### 3. –°–ª–∏—è–Ω–∏–µ –¥–≤—É—Ö –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–∞—Å—Å–∏–≤–æ–≤ —Å –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å—é
**–ó–∞–¥–∞—á–∞:** –°–ª–µ–π—Ç–µ –¥–≤–∞ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–∞—Å—Å–∏–≤–∞ –≤ –æ–¥–∏–Ω, —Å–æ—Ö—Ä–∞–Ω—è—è –æ–±–µ –∏—Å—Ö–æ–¥–Ω—ã–µ –≤–µ—Ä—Å–∏–∏ –∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç.

**–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ:** $O(1)$ –∞–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø–∞–º—è—Ç—å –Ω–∞ —ç–ª–µ–º–µ–Ω—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞.

---

## –°—Ä–µ–¥–Ω–µ

### 4. –†–µ–∞–ª–∏–∑—É–π—Ç–µ —Å–∫–∏–ø-–ª–∏—Å—Ç —Å –¥–∏–∞–ø–∞–∑–æ–Ω–Ω—ã–º–∏ –∑–∞–ø—Ä–æ—Å–∞–º–∏
**–ó–∞–¥–∞—á–∞:** –î–æ–±–∞–≤—å—Ç–µ –æ–ø–µ—Ä–∞—Ü–∏—é `range_query(l, r)`, –∫–æ—Ç–æ—Ä–∞—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ $[l, r]$ –∑–∞ $O(\log n + k)$ –≥–¥–µ $k$ ‚Äì —á–∏—Å–ª–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤.

**–ü–æ–¥—Å–∫–∞–∑–∫–∞:** –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø–æ–∏—Å–∫ –Ω–∞ —É—Ä–æ–≤–Ω–µ 0 –ø–æ—Å–ª–µ –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –ª–µ–≤–æ–π –≥—Ä–∞–Ω–∏—Ü—ã.

### 5. –ü–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–∞—è –∫—É—á–∞
**–ó–∞–¥–∞—á–∞:** –†–µ–∞–ª–∏–∑—É–π—Ç–µ –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω—É—é –¥–≤–æ–∏—á–Ω—É—é –∫—É—á—É (–∏–ª–∏ Leftist heap) —Å –æ–ø–µ—Ä–∞—Ü–∏—è–º–∏:
- `insert(x)` ‚Äì $O(\log n)$
- `extract_min()` ‚Äì $O(\log n)$
- `merge(h1, h2)` ‚Äì $O(\log n)$ –¥–ª—è Leftist, $O(\log m + \log n)$ –¥–ª—è binary

**–°–ª–æ–∂–Ω–æ—Å—Ç—å:** –ö–∞–∂–¥–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è —Å–æ–∑–¥–∞—ë—Ç $O(\log n)$ –Ω–æ–≤—ã—Ö —É–∑–ª–æ–≤.

---

## –°–ª–æ–∂–Ω–æ

### 6. –ü–æ–ª–Ω–æ—Å—Ç—å—é –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ–µ –¥–µ—Ä–µ–≤–æ –ø–æ–∏—Å–∫–∞
**–ó–∞–¥–∞—á–∞:** –†–µ–∞–ª–∏–∑—É–π—Ç–µ —Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ BST (AVL –∏–ª–∏ Red-Black), –≥–¥–µ –∫–∞–∂–¥–∞—è –≤–µ—Ä—Å–∏—è –æ—Å—Ç–∞—ë—Ç—Å—è –¥–æ—Å—Ç—É–ø–Ω–æ–π.

**–¢—Ä–µ–±–æ–≤–∞–Ω–∏–µ:** –í—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ $O(\log n)$, –ø–∞–º—è—Ç—å –Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—é $O(\log n)$.

**–ü–æ–¥—Å–∫–∞–∑–∫–∞:** –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ Path Copying. –ü—Ä–∏ –∫–∞–∂–¥–æ–º –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –∫–æ–ø–∏—Ä—É–π—Ç–µ —Ç–æ–ª—å–∫–æ –ø—É—Ç—å –æ—Ç –∫–æ—Ä–Ω—è –¥–æ —É–∑–ª–∞.

### 7. –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–µ —Å–ª–∏—è–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä
**–ó–∞–¥–∞—á–∞:** –†–µ–∞–ª–∏–∑—É–π—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é, –∫–æ—Ç–æ—Ä–∞—è –±–µ—Ä—ë—Ç N —Å–∫–∏–ø-–ª–∏—Å—Ç–æ–≤ (–∏–ª–∏ heap-–æ–≤) –∏ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ –∏—Ö —Å–ª–∏–≤–∞–µ—Ç –≤ –æ–¥–∏–Ω.

**–¢—Ä–µ–±–æ–≤–∞–Ω–∏–µ:** –°–ª–æ–∂–Ω–æ—Å—Ç—å $O(N \log N + T)$ –≥–¥–µ $T$ ‚Äì –æ–±—â–µ–µ —á–∏—Å–ª–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤.

**–ò–¥–µ—è:** –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ divide-and-conquer —Å –±–∏–Ω–∞—Ä–Ω—ã–º –¥–µ—Ä–µ–≤–æ–º —Å–ª–∏—è–Ω–∏–π.

### 8. Git-like —Å–∏—Å—Ç–µ–º–∞ –≤–µ—Ä—Å–∏–π —Å –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å—é
**–ó–∞–¥–∞—á–∞:** –†–µ–∞–ª–∏–∑—É–π—Ç–µ —Å–∏—Å—Ç–µ–º—É, –ø–æ—Ö–æ–∂—É—é –Ω–∞ Git, –≥–¥–µ:
- –ö–∞–∂–¥—ã–π commit ‚Äì –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ã–π —Å–Ω–∏–º–æ–∫ —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã
- –ú–æ–∂–Ω–æ –æ—Ç–∫–∞—Ç–∏—Ç—å—Å—è –∫ –ª—é–±–æ–º—É commit'—É
- –í–µ—Ç–≤–ª–µ–Ω–∏—è –∏ —Å–ª–∏—è–Ω–∏–µ –≤–µ—Ä—Å–∏–π

**–¢—Ä–µ–±–æ–≤–∞–Ω–∏–µ:** –°–ª–∏—è–Ω–∏–µ –≤–µ—Ä—Å–∏–π –∑–∞ –≤—Ä–µ–º—è, –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É –∏–∑–º–µ–Ω–µ–Ω–∏–π (–Ω–µ –≤—Å–µ–º—É –¥–µ—Ä–µ–≤—É).

---

# –°–æ–≤–µ—Ç—ã –ø–æ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è–º {id: "optimization-tips"}

## Memory Layout –∏ Cache Efficiency

1. **Skip Lists:** –•–æ—Ä–æ—à–æ –ª–æ–∫–∞–ª–∏–∑–æ–≤–∞–Ω—ã ‚Äì —á–∞—Å—Ç–æ –æ–±—Ä–∞—â–∞–µ—Ç–µ—Å—å –∫ —É–∑–ª–∞–º –Ω–∞ –æ–¥–Ω–æ–º —É—Ä–æ–≤–Ω–µ
   ```
   # CPU cache –ª—é–±–∏—Ç —ç—Ç–æ:
   Level 0: [node_0] -> [node_1] -> [node_2] -> ...  # –õ–∏–Ω–µ–π–Ω—ã–π –¥–æ—Å—Ç—É–ø
   ```

2. **AVL/RB Trees:** –ü–ª–æ—Ö–æ –ª–æ–∫–∞–ª–∏–∑–æ–≤–∞–Ω—ã ‚Äì –º–æ–∂–µ—Ç –±—ã—Ç—å –∫—ç—à-–ø—Ä–æ–º–∞—Ö –Ω–∞ –∫–∞–∂–¥–æ–º —É–∑–ª–µ
   ```
   # CPU cache –Ω–µ –ª—é–±–∏—Ç —ç—Ç–æ:
   Tree:     [root] (somewhere in memory)
              /  \
         [left]  [right]  (completely different cache line)
   ```

3. **–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è:** –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ **B-Trees** –∏–ª–∏ **Skip Lists** –≤–º–µ—Å—Ç–æ BST –¥–ª—è –±–æ–ª—å—à–∏—Ö –æ–±—ä—ë–º–æ–≤ –¥–∞–Ω–Ω—ã—Ö.

## –ü–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º

1. **Skip Lists:** –õ–µ–≥–∫–æ —Å–¥–µ–ª–∞—Ç—å lock-free (–∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –≤ Java ConcurrentSkipListMap)
   ```pseudocode
   # –û–ø–µ—Ä–∞—Ü–∏—è –ø–æ–∏—Å–∫–∞ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç lock-–æ–≤ –≤–æ–æ–±—â–µ!
   func search_concurrent(key: K) -> V:
       # –ü—Ä–æ—Å—Ç–æ —á–∏—Ç–∞–µ–º —É–∑–ª—ã, –±–µ–∑ changes
       # –î—Ä—É–≥–∏–µ –ø–æ—Ç–æ–∫–∏ –º–æ–≥—É—Ç –≤—Å—Ç–∞–≤–ª—è—Ç—å/—É–¥–∞–ª—è—Ç—å –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ
   ```

2. **–§–∏–±–æ–Ω–∞—á—á–∏–µ–≤—ã –∫—É—á–∏:** –°–ª–æ–∂–Ω–æ —Ä–∞—Å–ø–∞—Ä–∞–ª–ª–µ–ª–∏—Ç—å (–º–Ω–æ–≥–æ small updates)

3. **Leftist Heaps:** –í–æ–∑–º–æ–∂–µ–Ω –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–π merge —á–µ—Ä–µ–∑ divide-and-conquer

## –ö–æ–º–ø—Ä–µ—Å–∏—è –ø–∞–º—è—Ç–∏

–î–ª—è –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä —á–∞—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É—é—Ç:
1. **Hash Consing** ‚Äì –∫—ç—à–∏—Ä–æ–≤–∞—Ç—å –∏–¥–µ–Ω—Ç–∏—á–Ω—ã–µ –ø–æ–¥—Å—Ç—Ä—É–∫—Ç—É—Ä—ã –ø–æ —Ö–µ—à—É
2. **–°—Ç—Ä—É–∫—Ç—É—Ä–Ω–æ–µ —Å–∂–∞—Ç–∏–µ** ‚Äì –µ—Å–ª–∏ –¥–≤–∞ —É–∑–ª–∞ –∏–º–µ—é—Ç –æ–¥–∏–Ω–∞–∫–æ–≤–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –∏ –ø–æ–¥–¥–µ—Ä–µ–≤–æ, –æ–Ω–∏ –º–æ–≥—É—Ç —É–∫–∞–∑—ã–≤–∞—Ç—å –Ω–∞ –æ–¥–∏–Ω –∏ —Ç–æ—Ç –∂–µ –æ–±—ä–µ–∫—Ç –≤ –ø–∞–º—è—Ç–∏

---

# –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã {id: "additional-resources"}

## –ö–Ω–∏–≥–∏ –∏ —Å—Ç–∞—Ç—å–∏

- **"Purely Functional Data Structures" ‚Äî Chris Okasaki** ‚Äì –∫–ª–∞—Å—Å–∏–∫–∞ –ø–æ –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ã–º —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º
- **"Algorithm Design Manual" ‚Äî Steven Skiena** ‚Äì —Ö–æ—Ä–æ—à–∏–π –æ–±–∑–æ—Ä —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–Ω—ã—Ö
- **"Advanced Data Structures" ‚Äî Peter Brass** ‚Äì —É–≥–ª—É–±–ª–µ–Ω–Ω–æ–µ –∏–∑—É—á–µ–Ω–∏–µ

## Online Resources

- **Visualization:** https:#www.cs.usfca.edu/~galles/visualization/Algorithms.html
- **Skip List Paper:** William Pugh's original paper (1990)
- **Persistent Data Structures:** MIT CSAIL lectures

## –ò—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ —Ñ–∞–∫—Ç—ã

1. **Skip Lists** (1990) ‚Äì –£–∏–ª—å—è–º –ü–∞—Ñ –ø—Ä–µ–¥–ª–æ–∂–∏–ª –∫–∞–∫ –±–æ–ª–µ–µ –ø—Ä–æ—Å—Ç—É—é –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤—É –¥–µ—Ä–µ–≤—å—è–º.
2. **–§–∏–±–æ–Ω–∞—á—á–∏–µ–≤—ã –∫—É—á–∏** (1984) ‚Äì –ø—Ä–∏–¥—É–º–∞–ª–∏ –§—Ä–µ–¥–º–∞–Ω –∏ –¢–∞—Ä–¥–∂–∞–Ω; –Ω–∞—à–ª–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≤ Dijkstra.
3. **–ü–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã** ‚Äì –≤–æ—Å—Ö–æ–¥—è—Ç –∫ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–º—É –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—é (Lisp, 1960s).

---

$\text{–û—Ç —É—á–µ–Ω–∏–∫–∞ –¥–ª—è —É—á–µ–Ω–∏–∫–æ–≤.}\\ \text{\textcolor{red}{–° –ª—é–±–æ–≤—å—é} –∫ \textcolor{yellow}{–¢-–û–±—Ä–∞–∑–æ–≤–∞–Ω–∏—é}.}\\ \textcolor{#86cecb}{–í–∞–¥–∏–º\ –•—Ä–∏—Å—Ç–µ–Ω–∫–æ.}$
